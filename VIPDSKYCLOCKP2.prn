   0000                 ;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
                        ;
                        ;	File:		VIPDSKYCLOCKP2.asm
                        ;
                        ;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
                        ; 	Author:	S. Botts
                        ;	Size:		81.2 KB (83,181 bytes)
                        ;	Copyright: (c)2015 by SBOTTS - All righty then.
                        ;
                        ;	Purpose:	Demonstrates an Apollo Guidence Computor (AGC) 
                        ;			(DSKY)Display Keyboard Unit with VIP.  
                        ;	Checksum:	688D
                        ;	CRC-32:	E571B87A
                        ;	Versions:
                        ;	Date:		Tuesday, July 21, 2015, 11:10:53 PM 
                        ;	CPU:		RCA 1802 (1802 COSMAC family)
                        ;
                        ;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
                        
                        ;--------------------------------------------------------------------------
                        ;	Versions:
                        ;	1.3	Date:	Tuesday, July 21, 2015, 11:10:53 PM - Added NOUNs 65, 36, Keys:  "D", "E", "F" 
                        ;	1.2 	Date:	Sunday, July 19, 2015, 09:44:35 PM - First Release. Only VERBs 16, 35, 36, KEYs "A", "B"
                        ;	1.1 	Date:	Saturday, July 11, 2015, 12:43:52 PM - MET Clock with formatting
   0000                 ;	1.0 	Date:	Sunday, Sunday, June 28, 2015, 8:16:02 AM - MET Clock Display only
                        ;
                        ;****************************(DO NOT MODIFY)**************************************
   0000                 r0		EQU	0	;DMA address 
   0001                 r1		EQU	1	;Interrupt Address 
   0002                 r2		EQU	2	;Stack 
   0003                 r3		EQU	3	;MAIN Program Counter (PC)
                        ;****************************(DO NOT MODIFY)**************************************
   0004                 r4		EQU	4	;INDEX
   0005                 r5		EQU	5	;COUNTERs
   0006                 r6		EQU	6	;Memory Pointer #1- ALSO USED TO STOrE VAr INST
   0007                 r7		EQU	7	;Memory Pointer #2- HOLDS VAr INSTrUCTION
   0008                 r8		EQU	8	;counter in display routine
   0009                 r9		EQU	9	;INTERRUPT COUNTER  - 61 times per sec in interrupt (DO NOT MODIFY)
   000a                 ra		EQU	10	;
   000b                 rb		EQU	11	;
   000c                 rc		EQU	12	;Second PC -> Returns control to MAIN PC (R3)
   000d                 rd		EQU	13	;Third PC -> Returns control to RC
   000e                 re		EQU	14	;KEY Press Result
   000f                 rf		EQU	15	;
                        ; Redundant reg defines...
   000a                 r10		EQU	10	;
   000b                 r11		EQU	11	;
   000c                 r12		EQU	12	;
   000d                 r13		EQU	13	;
   000e                 r14		EQU	14	;
   000f                 r15		EQU	15	;
                        
                        ;
                        ;=========================================================================
                        ;=============================PAGE 0000===================================
                        ;=========================================================================
   0000                 	org	$0000
                        ;
   0000                 start:
   0000   f8 cd         	ldi	LOW TV_INT	;Point to 1861 video interrupt $8D
   0002   a1            	plo	r1
   0003   f8 01         	ldi	HIGH TV_INT	;Point to 1861 video interrupt $8D
   0005   b1            	phi	r1
                        
   0006   f8 94         	ldi	LOW STACK	;R2 is stack in RAM $4D
   0008   a2            	plo	r2 
   0009   f8 00         	ldi	HIGH STACK
   000b   b2            	phi	r2	;Stack
                        
   000c   f8 20         	ldi	LOW L0014		;Make R3 the PC 
   000e   a3            	plo	r3	;Preset all these RN.1 registers to this page.
   000f   f8 00         	ldi	HIGH L0014		;Should be page zero...
   0011   b3            	phi	r3	;PC
                        
                        ;	ghi	r0	;DMA - Should be Page 0
   0012   f8 00         	ldi	$00
                        ;	phi	r1	;Point to Interrupt page
                        ;	phi	r2	;Point to Stack page
                        
                        ;continue clearing the R(N).1 (MSB) counters 
   0014   b4            	phi	r4	;pointer
   0015   b5            	phi	r5	;pointer
   0016   b6            	phi	r6	;Self mod code pointer	
   0017   b7            	phi	r7	;vAR instruction
   0018   b8            	phi	r8	;Clear R8.1 counter in Display
   0019   b9            	phi	r9	;Clear R9.1 61 counts/set
   001a   ba            	phi	ra
   001b   bb            	phi 	rb
                        ;	phi 	rc	;point to key page
   001c   bd            	phi 	rd
   001d   be            	phi 	re
   001e   bf            	phi 	rf
                        ;**********************REG initializations are complete**********************
                        
                        
                        ;Switch PC to R(3)
   001f   d3            	sep	r3		; SET PC to R3 HERE
                        ;Switch INDEX Counter to R(2)
   0020                 L0014:
   0020   e2            	sex	r2		; SET X to R2 HERE
                        
                        ;************************************************************************
                        ; Real Time Clock - Mission Elapsed Time (MET)
                        ;************************************************************************
                        ;
                        ;Description: 
                        ;This is the master background task for VIP_DSKY updated by teh VIDEO 
                        ;Interrupt.
                        ; 
                        ;
                        ;Registers Used:
                        ;	R(9) = Interrupt timer (Do not modify - Read only )
                        ;	R(3) = HHHMMSS Pointer	
                        ;	R(4) = Index Reg R(X)
                        ;	R(5) = NA
                        ;	R(A) = Counter
                        ;
                        ;************************************************************************
                        
                        
   0021                 STARTCLK:
   0021   69            	inp	1		; Ready to start clock -> Turn ON TV!
                        
   0022                 L0024:
   0022   f8 00         	ldi	HIGH KEYS	;
   0024   b4             	phi 	r4		;Use R(4)
   0025   f8 95          	ldi	LOW KEYS	;KEY Buffer
   0027   a4             	plo 	r4
                        
   0028   f8 10          	ldi	$10
   002a   ae             	plo	re
   002b                 KES:	
   002b   2e            	dec	re
                        
   002c   8e            	glo	re
   002d   fa 0f         	ani	$0F	;mask off msb
   002f   54            	str	r4	;store on stack
   0030   e4            	sex	4
   0031   62                	out	2	;output via R(x) -> BUS
                        
   0032   e2               	sex	2
                        
   0033   24             	dec	r4	;point back to buffer
                        
   0034   36 41          	b3	KEY	;key pressed?
                        
   0036   8e             	glo	re
   0037   3a 2b          	bnz	KES	;no - scan keys
                        	
   0039   89            	glo	r9		;get interrupt timer (R9.0) 
   003a   fb 3d         	xri	$3D		;61 counts?
   003c   3a 22         	bnz	L0024		;Nope - check again (key in here?)
   003e   a9            	plo	r9		;YES it is! - Reset interrupt timer and proceed...
                        
                        ;*************************************************************************
                        ; 1 HZ LOOP Begins here... FLASH Q LED to indicate
                        ;*************************************************************************
                        ;First check for key command...
                        ;*************************************************************************
   003f   30 4e          	br	NOKEY
                        
   0041                 KEY:
                        ;======================TEST====================================
                        
                        ; 	ldi	HIGH NOUN_VERB	;point it to some place to store key
                        ; 	phi 	r4			;Use R(4)
                        ; 	ldi	LOW NOUN_VERB+1	;Point to a good screen location
                        ; 	plo 	r4;
                        ;
                        ;
                        ;	glo	re		;use switches for test
                        ;  	ani	$0F		;mask off msb
                        ; 	str	r4
                        ;======================TEST====================================
                        	
   0041   36 41         	b3	$		;Wait here for the key to get released!
                        
   0043   f8 02         	ldi	HIGH	CPROC
   0045   bc            	phi	rc
   0046   f8 01         	ldi	LOW	CPROC
   0048   ac            	plo	rc
   0049   dc            	sep	rc
                        
   004a   f8 00         	ldi	$00		;yes since there was a pressed key 
   004c   b9            	phi	r9		;lets reset the clock timer again
   004d   a9            	plo	r9		;so no overflow occurs
                        
   004e                 NOKEY:
                        
                        ;*****************FLASH Q LED ********************************
                        ; this is a 1 sec on off flash... 
                        ; heart beat used to show RTC is running
                        ; and updates and Display Flashing Digits as needed.
                        ;**************************************************************
                        ;
   004e   39 53         	bnq	L001C		; is Q ON?
   0050   7a            	req			;YES - turn it off
   0051   30 54         	br	L001D
   0053                 L001C:	
   0053   7b            	seq			;NO - Turn it on
                        
                        ;*************************************************************
                        ;***************** TIMER LOOP ********************************
                        ;*************************************************************
                        ;
                        ;This is the Main Clock loop. It does not display the time, but
                        ;it maintains an elapsed timer.  It Does the HH:MM:SS count in 
                        ;RAM and controls the rollovers to xx:59:59 
                        ;Zero Hour is checked on exit and gets reset then if needed.
                        ;
                        
   0054                 L001D:
                        ;	ghi	r3		;Reset Rx.1 to Current page (0)
   0054   f8 00         	ldi	$00		;Reset Rx.1 to page (0)
   0056   b5            	phi	r5		;R5.1 
   0057   b4            	phi	r4		;R4.1 
   0058   b6            	phi	r6		;R6.1 
   0059   b7            	phi	r7		;R7.1 
                        
   005a   f8 a0         	ldi	HHMMSS+5	;Time stored in RAM (HH:MM:SS))
   005c   a4            	plo	r4		;R(4) will be the index
                        ;	plo	r5
   005d   e4             	sex	r4	 	;make R(4) the X Reg
   005e                 DIGIT:
   005e   f0            	ldx			;get time_LSD(x) -> RA.0
   005f   aa            	plo	ra
   0060   1a            	inc 	ra		;Increment the counter in R(A)
   0061   8a            	glo	ra
   0062   54            	str	r4		;put it back in RAM
   0063   8a             	glo	ra
   0064   fb 0a         	xri	$0A		;is it 10? 
   0066   3a 79         	bnz	FXDISP	;Not yet - but we are done here no MSD to increment
                        				;Yes = 0  
   0068   73            	stxd			;then store it time(x) and decrement pointer to point to MSB
                        
   0069   f0            	ldx			;get time_MSD(x) -> RA.0
   006a   aa            	plo	ra
   006b   1a            	inc 	ra		;Increment the counter in R(A)
   006c   8a            	glo	ra
   006d   54            	str	r4		;put it back in RAM
   006e   8a             	glo	ra
   006f   fb 06         	xri	$06		;is it 60? (NOTE:even though we check for 60 hours we'll never get there)
   0071   3a 79         	bnz	FXDISP	;Not yet - but we are done here but hours need checking
                        				;Yes = 0  
   0073   73            	stxd			;then store it time(x) and decrement pointer
   0074   84            	glo	r4		;check was this the last digit? (x=HHMMSS)
   0075                 NEXTDIG:
   0075   fb 9a         	xri	HHMMSS-1
   0077   3a 5e         	bnz	DIGIT		;No, get next digit
                        ;	br	FXDISP	;Yes, check if Hours = 24
                        
                        ;
                        ;********************************************
                        ;		FXDISP
                        ;**NOTE** this can move to Main Clock Loop
                        ;********************************************
                        ;Fix the HH display and counters for 24 Hr 
                        ;clock rollover. 23:59:59 -> 00:00:00
                        ;********************************************
                        ;
                        
   0079                 FXDISP:			; fix for current display move mem into RA -> RF
   0079   f8 9b         	ldi	HHMMSS
   007b   a4            	plo	r4
   007c   72            	ldxa			;Pick up 10's hours digit
   007d   f6            	shr			;01 >> 0 + DF
   007e   f6            	shr			;check for hour 20: (Bit 0010)
   007f   3b c4         	bnf	DISPLAY 	;still <20: - not there yet just update the display!
                        
   0081   72            	ldxa			;Pick up 1's Hours
   0082   fb 04         	xri	$04		;is it the hour 24:00?
   0084   3a c4         	bnz	DISPLAY 	; Nope keep going...
                        
                        ;... it's zero hour midnight!
                        
   0086   f8 9b         	ldi 	HHMMSS
   0088   a4            	plo	r4	;then store it time(x) and decrement pointer
   0089   f8 00         	ldi 	$00
   008b   54            	str	r4
   008c   14            	inc	r4
   008d   54            	str	r4	; fall through to display... 
   008e   30 c4         	br	DISPLAY
                        ;======================================================
                        ;
                        ;		PAGE 0 RAM BUFFERS
                        ;
                        ;======================================================
                        
                        ;********************************************
                        ;		IRQ STACK BUFFER
                        ;********************************************
                        ;these next three locations are the stack for 
                        ;the intrerrupt in RAM ...
                        ;********************************************
                        
   0090   00 00 00 00   	db	$00, $00, $00, $00
   0094                 STACK:
   0094   00            	db	$00
   0095                 KEYS:
   0095   00 00 00      	db 	$00, $00, $00
   0098                 CMD:
   0098   00            	db 	$00
   0099                 CDEX:
   0099   00            	db 	$00
   009a                 CCNT:
   009a   00            	db 	$00
                        ;********************************************
                        ;		RTC COUNTERS
                        ;********************************************
                        ;Maximum count is 23:59:59 -> 00:00:00
                        ; Note: it is set to 23:59:58 on reset 
                        ;       to test the big rollover
                        ;********************************************
   009b                 HHMMSS:
   009b                 HH:
   009b   02 03         	db	$02, $03	;Hours HH
   009d                 MM:
   009d   05 09         	db 	$05, $09	;Minutes MM
   009f                 SS:
   009f   05 08         	db	$05, $08	;Seconds SS
                        
                        ;******DAY COUNTER 000 -> 365(6) can go here...
                        ;but remember 366 day leap years? 2016, 2020, 2024,2028, 2032...
                        
                        ;*********************************************************************************
                        ;			DSKY DISPLAY FORMAT
                        ;*********************************************************************************
                        ;This is the BUFFER in RAM that the command and prog processes control the values here.  
                        ;It calls VIP_DIS to format and display for the 1861 PIXIE display.
                        ;The upper nibbles control how the output is displayed and special (+/-_) chars are shown
                        ;
                        ; The DISPLAY REGISTERS1-3. ACTY, NOUN, VERB, AND PROG CAN ALL USE THESE FORMAT controls
                        ; All 5 LINES WITH 6 CHARS PER LINE ARE DISPLAYED EACH UPDATE. The formats are:
                        ; $Fn MSB =($F)lash n = digit (flashes this digit alternating the pattern and $00
                        ; $Cn MSB =($C)LEAR n = digit (does not show this digit)
                        ; for (S)ign:
                        ; $0n MSB =($0)CLEAR (OCTAL), n = digit -> CLEARS THE PATTERN NONE OR THIRD "F" KEY
                        ; $1n MSB =($1)"-" (NEGITIVE DEC), n = digit -> STORES THE HORIZONTAL MINUS PATTERN FIRST "F" KEY
                        ; $2n MSB =($2)"+" (POSITIVE DEC), n = digit -> ADDS THE  VERTICAL PLUS PATTERN SECOND "F" KEY
                        ;Just store them here with the conrtol bits set and the display formatter will take 
                        ;care of the display behaviour. 
                        ;*********************************************************************************
                        
                        ;     	-------------------------------
                        ;DIGI=	SD5	D5	D4	D3	D2	D1
                        ;+ADD=	+0	+1	+2	+3	+4	+5
                        ;          -------------------------------
   00a1                 PROG_REG:
   00a1   c0 a1 c2 c3   	db	$C0,	$A1,	$C2,	$C3,	$00,	$00
   00a5   00 00         
                        
   00a7                 NOUN_VERB:	
                        ;	db	$C0,	$00,	$00,	$C0,	$00,	$00	;Display default with A=00 and B=00
   00a7   c0 fa fa c0   	db	$C0,	$FA,	$FA,	$C0,	$FB,	$FB	;Display default with flashing AA BB
   00ab   fb fb         
                        ;
                        ;====================LINE=======================+
                        
                        ;
                        
   00ad                 REG1:
   00ad   52 00 00 00   	db	$52,	$00,	$00,	$00,	$00,	$00	
   00b1   00 00         
   00b3                 REG2:
   00b3   51 00 00 00   	db	$51,	$00,	$00,	$00,	$00,	$00
   00b7   00 00         
   00b9                 REG3:
   00b9   52 00 00 00   	db	$52,	$00,	$00,	$00,	$00,	$00
   00bd   00 00         
                        
                        ;**** Add more VERB/NOUN storage to do more levels...
   00bf                 VERB:
   00bf   00 00         	db	$00,	$00
   00c1                 NOUN:
   00c1   00 00         	db	$00,	$00
                        
   00c3                 PROG0:
   00c3   00            	db	$00
                        
                        
                        ;
                        ;************************************************************************
                        ;		DISPLAY PROCESS 
                        ;
                        ;************************************************************************
                        ;Description: 
                        ;This is the Simulation tasks for VIP_DSKY runs with these these two 
                        ;subroutines arebcalled to create and format the desired displays.
                        ;
                        ;1) AGC_PROC1= this subroutine simulates some AGC functions to give the
                        ;               display process somthing to display. 
                        ;2) VIP_DS	 = This subroutine simulates the DIS part of the DSKY on a 
                        ;             COSMAC VIP Display.
                        ;Registers Used:
                        ;
                        ;	R(D) = Program Counter (calls the subroutines)
                        ;    R(C) = Program Counter (calls internal subroutines)
                        ;    R(3) = RETURN PC (DO NOT CHANGE in SUBR)
                        ;    R(E) = Key Found (Use with care)
                        ;
                        ;************************************************************************
                        
   00c4                 DISPLAY:
                        
   00c4   f8 03         	ldi 	HIGH AGC_PROC1	;AGC PROCESS DEMO Sub Page
   00c6   bd            	phi	rd
   00c7   f8 01         	ldi 	LOW AGC_PROC1	;AGC PROCESS DEMO Sub entry
   00c9   ad            	plo	rd
   00ca   dd            	sep 	rd			;call AGC DEMO PC = R(D) now
                        
   00cb   f8 02         	ldi 	LOW VIP_DS		;DSKY DISPLAY Sub Page
   00cd   ad            	plo	rd
   00ce   f8 01         	ldi 	HIGH VIP_DS	;DSKY DISPLAY Sub entry
   00d0   bd            	phi	rd
                        	
   00d1   dd            	sep 	rd			;call DiS play! PC = R(D) now
                        
   00d2   30 22         	br	L0024		; returns here -> continue!
                        
                        ;==============================================================
                        ;======================== CONSTANTS =========================== 
                        ;==============================================================
                        ;
                        ;These are used for memory and display pointers
                        ;
                        ;********************************************
                        
   00d4                 PROG_OFFSET:
   00d4   a2            	DB	LOW PROG_REG+1	;ACTY
   00d5   a5            	DB	LOW PROG_REG+4	;P1.D1
   00d6   a6            	DB	LOW PROG_REG+5	;P1.D0
   00d7                 NV_OFFSETS:
   00d7   a7            	DB	LOW NOUN_VERB+0
   00d8   a8            	DB	LOW NOUN_VERB+1
   00d9   ab            	DB	LOW NOUN_VERB+4
   00da   ac            	DB	LOW NOUN_VERB+5
   00db                 MET_OFFSETS:
                        	
   00db   b1            	DB	LOW REG1+4	;10's HRs R1.D1
   00dc   b2            	DB	LOW REG1+5	; 1's HRs R1.D0
   00dd   b7            	DB	LOW REG2+4	;10's MINs R2.D1
   00de   b8            	DB	LOW REG2+5	; 1's MINs R2.D0
   00df   bb            	DB	LOW REG3+2	;10's SECs R3.D3
   00e0   bc            	DB	LOW REG3+3	; 1's SECs R3.D2
                        
   00e1                 REG_LINE:
   00e1   a1            	DB	LOW PROG_REG
   00e2   a7            	DB	LOW NOUN_VERB
   00e3   ad            	DB	LOW REG1
   00e4   b3            	DB	LOW REG2
   00e5   b9            	DB	LOW REG3
                        ;
                        ;=========================================================================
                        ;=============================PAGE 0100===================================
                        ;=========================================================================
   0100                 	org	$0100
                        
                        ;************************************************************************
                        ;DSKY Display Formatter for COSMAC VIP TV
                        ;************************************************************************
   0100                 VIP_DS_RET:
   0100   d3            	sep	r3
   0101   00            	db	$00
   0102                 VIP_DS:
                        ;************************************************************************
                        ;
                        ;Description: This is the DiSplay part of DSKY. Since COSMAC VIP uses
                        ;the 1861 PIXIE display all the registers maintained by the COMMAND Process
                        ;are translated into the video display. It is convenient due to paging to
                        ;use one 256-byte page for this display.  We can fit most of the standard
                        ;DSKY in this space but the horizontal lines between the registers 
                        ;and the NOUN and VERB Lamps are not dispalyed. It is also possible to 
                        ;show the status lamps but this is not implemented in this version, all 
                        ;256 bytes are displayed for each update.  The digits are translated by
                        ;a format code that tells how the display appears:
                        ;
                        ;Use:
                        ;	N = 0 - 9 (Digits)
                        ;	0N = Normal digit
                        ;	CN = Clear the cell (N is not shown on screen)
                        ;	FN = Flash the cell (alternate "N" -> " " based on Q State)
                        ;	5N = Sign  Looks kind of like an "S" 0101b (" ", "+", "-", " ", etc...)
                        ;	50 = x0 (xx00b) = " " (OCTAL)
                        ;	51 = x1 (xx01b) = "-" (DECIMAL NEG)
                        ;	52 = x2 (xx10b) = "+" (DECIMAL POS)
                        ;	53 = x3 (xx11b) = " " (OCTAL)
                        ;	DN = FLASHING SIGN? adds one bit to 5N indicate a flash state (1101b)
                        ;
                        ;The display formatter moves the digits from the OUTPUT_REG and puts them
                        ;in speific locations on the VIDEO_BUF page.  each line is placed as 7 digits
                        ;picked up and stored from R->L pointed to by a column counter by DEC R(x).
                        ;The adddress offsets are added and stored and the R(x) offset is the same
                        ;for REG+R(x) -> VIDEO+R(x) buffer.  The command nybble is masked off and this
                        ;result switch tree determines how the 8 digit bit patterns are stored in the 
                        ;video buffer. Each digit in the OUTPUT_REG translates to 8 video lines in 
                        ;the video buffer.
                        ;
                        ;Registers Used:
                        ;	R(4) = VIDEO_BUFFER Display DESTINATION pointer
                        ;	R(5) = ROM Pattern & Table pointer
                        ;	R(6) = DSKY Registers SOURCE pointer
                        ;	R(7) = Character REG position and DSKY VIDEO COLUMN pointer
                        ;	R(8) = Character display pattern line pointer:
                        ;	R(A) = Temp Storage
                        ;	R(B) = Line Counter?
                        ;	R(C) = Column counter?
                        ;	R(D) = PC for this subroutine
                        ;
                        ;
                        ;VIP MON ROM LOCATIONS USED Defines:
   8100                 index		EQU	8100h		;Offset to patterns in ROM
   8110                 bitmap	EQU	8110h		;Top of bit patterns in ROM "0"
                        ;***********************************************************************************
                        
                        
   0102   f8 81         	ldi	HIGH index		;Set ROM table's page (80xx)to convert patterns
   0104   b5            	phi	r5			;Display Pattern (get 5)  
                        	
   0105   f8 00         	ldi	HIGH REG_LINE	;point to RAM regigster page to get digits
   0107   b7            	phi	r7			;
   0108   ba            	phi	ra
   0109   bc            	phi	rc
   010a   f8 e1         	ldi	LOW REG_LINE	;First digit's offset
   010c   a7            	plo	r7			;DIGIT NIBBLE POINTER (SOURCE)
                        
   010d   f8 01         	ldi	HIGH VIDEO_LINE	;Point to video Page locations
   010f   b6            	phi	r6			;
   0110   f8 c6         	ldi	LOW VIDEO_LINE	;Point to first location
   0112   a6            	plo	r6			;
                        
   0113   f8 05         	ldi	HIGH DSKY_L1	;INDEX point to RAM display page (0300) to store
   0115   b4            	phi	r4			; patterns for char PATTERN lines on the DSKY
                        
                        	
   0116                 L0066:
   0116   f8 06         	ldi	$06		;Max Columns+1
   0118   ab            	plo	rb
   0119   f8 00         	ldi	$00		;clear MSBs too (MAY NOT BE NEEDED)
   011b   bb            	phi	rb
   011c   b8            	phi	r8
                        
   011d   06            	ldn	r6		;get the DSKY OFFSET
   011e   a4            	plo	r4		;storage pointer
                        
   011f   07            	ldn	r7		; Pick up pointer to digit from Source (REG)
   0120   aa            	plo	ra		; Pick up pointed digit from Source (REG)
   0121   ac            	plo	rc		; character index from sSource (REG)
                        
   0122                 L0067:
   0122   0a            	ldn	ra		;load via R(A) but don't increment...
   0123   aa            	plo	ra		;SAVE IT in R(A) for processing
                        
   0124   30 50         	br	CONTCH	;Process Control Nibble
                        
   0126                 DISPCH:
   0126   fc 00         	adi	LOW index	;Point to the pattern in ROM was $A9  (xx00)+ N = Digit
   0128   a5            	plo	r5		;put it in R(5)
   0129   05            	ldn	r5		;Pick up the Nth byte of the Display RAM pattern from ROM table
   012a   a5            	plo	r5
                        		
   012b   f8 05         	ldi	$05		;Do this for all 5 lines of the character bit pattern
   012d   a8            	plo	r8		;Line count in R8.0
                        
   012e                 L0079:
   012e   45            	lda	r5		;get from ROM pattern
   012f   54            	str	r4		;Store on display page
   0130   28            	dec	r8		;next lines
   0131   88            	glo	r8		;Get next digit
   0132   32 3a         	bz	L0080		;All bit patterns stored? YES- get next digit.
   0134   84            	glo	r4		;No keep storing patterns
   0135   fc 08         	adi	$08		;point to next TV line (this points to the byte directly below the last)
   0137   a4            	plo	r4		;on the TV screen
   0138   30 2e         	br	L0079		; get next pattern
   013a                 L0080:
                        
   013a   84            	glo	r4			;get last displayed digit index  
   013b   fb f6         	xri	LOW DSKY_R3+$26	; all digits & lines?
   013d   32 00         	bz	VIP_DS_RET		; yes --> get out of here!
                        
   013f   2b            	dec	rb		; column counter
   0140   8b            	glo	rb
   0141   3a 47         	bnz	NEXCOL	; all 5 digits on this line done? 
   0143   17            	inc	r7		; yes-> index pointers to get next lines
   0144   16            	inc	r6		; (both REG & DSKY Lines)
   0145   30 16         	br	L0066		;back to outside loop to pick up new pointers
                        
                        				; no -> keep going on this line
                        ; do some math on indexes to point to the next DSKY Column
                        ; and...to get another digit
   0147                 NEXCOL:
   0147   84            	glo	r4		; move index R4 to point to next DSKY COLUMN
   0148   fc e1         	adi	$E1		; point to top of next display columnn was e1 (-31)
   014a   a4            	plo	r4
   014b   1c            	inc 	rc		; next digit in REG	(can just index as they are in order)
   014c   8c            	glo	rc		; REG digit index pointer ( may be redundant?)
   014d   aa            	plo	ra
   014e   30 22         	br	L0067		; keep going on the inside loop
                        
                        ;***************************************************
                        ; DISPLAY CONTROL CHAR PROCESSING
                        ;***************************************************
                        ;Assumes entry with byte to be displayed is in R(5)
                        ;with the upper Nibble being the control bits
                        ;and the lower the digit to display
                        ;***************************************************
                        
   0150                 CONTCH:
   0150   8a            	glo	ra	;get the found cont+digit
   0151   fa f0         	ani	$f0	;Mask the random digit
   0153   a5            	plo	r5	;save it in RB.0
                        
   0154   85            	glo	r5
   0155   fb 00         	xri	$00		;=none?
   0157   32 6d         	bz	FIXCH 	;just show it...
                        
   0159   85            	glo	r5
   015a   fb c0         	xri	$C0		;=Clear?
   015c   32 77         	bz	CLRCH		;Clear this char
                        
   015e   85            	glo	r5
   015f   fb f0         	xri	$F0		;=Flash?
   0161   32 73         	bz	FLASH		;alternate this char
                        
   0163   85            	glo	r5
   0164   fb 50         	xri	$50		;=Sign?
   0166   32 89         	bz	SIGN		;"+, -" or clear
                        
   0168   85            	glo	r5
   0169   fb a0         	xri	$A0		;"PROG INDIC" 
   016b   32 7e         	bz	INDC_A	;flashing cursor
                        
                        ;************************NOT USED IN THIS VERSION***************************************
                        ;also display indicators "$B0" 
                        ;are the indicator "bulbs"
                        ;these may be 4 lines vs. 5 lines?
                        ;locate on left hand displays
                        ;$FE pattern
                        ;[UPLINK] [NO ATT][KEY REL] [OPR ERR] 
                        ;[TEMP] [PROG] [ALT] [VEL]
                        ;
                        ;	glo	r5
                        ;	xri	$B0		;Status [Bulbs]
                        ;	bz	INDC_B	;
                        ;************************NOT USED IN THIS VERSION***************************************
                        
                        ;ELSE: just fall through here for un implemented or unknown
                        	
   016d                 FIXCH:
   016d   8a            	glo	ra		;get the found cont+digit
   016e   fa 0f         	ani	$0F		;Mask the random control code;
   0170   aa            	plo	ra
   0171   30 26         	br	DISPCH	;just show it..
                        
   0173                 FLASH:
   0173   39 77         	bnq	CLRCH	; if Q is off clear it
   0175   30 6d         	br	FIXCH	; if Q is on just show it..	
                        	
   0177                 CLRCH:
   0177   f8 05         	ldi	$05		;Do this for all 5 lines of the character bit pattern
   0179   a8            	plo	r8		;Line count in R8.0
   017a   f8 00         	ldi	$00		;all lines off
                        ;	plo	 r5
   017c   30 9e         	br	WS000	
                        
                        ;**************************************************************************
                        ;NOTE: this section may be re written to use routine located at WS000
                        ;      enter with R5 = 0 for complete count - should work?
                        ;**************************************************************************
                        ;D0079:
                        ;	glo	r5		;get from ROM pattern
                        ;	str	r4		;Store on display page
                        ;	dec	r8		;next lines
                        ;	glo	r8		;Get next digit
                        ;	bz	L0080		;All bit patterns stored? YES- get next digit.
                        ;	glo	r4		;No keep storing patterns
                        ;	adi	$08		;point to next TV line (this points to the byte directly below the last)
                        ;	plo	r4		;on the TV screen
                        ;	br	D0079		; get next pattern
                        ;**************************************************************************
                        
   017e                 INDC_A:
   017e   f8 05         	ldi	$05		;Writes 5 lines of bit pattern
                        
   0180   a8            	plo	r8		;Line count in R8.0
                        
   0181   f8 ff         	LDI	$FF		;1st pattern 
   0183   39 9e         	bnq	WS000		; is Q ON?
   0185   f8 00         	LDI	$00		;YES then turn the 2nd pattern on
   0187   30 9e         	br	WS000
   0189                 SIGN:
   0189   f8 05         	ldi	$05		;Writes 5 lines of bit pattern
   018b   a8            	plo	r8		;Line count in R8.0
                        
   018c   8a            	glo	ra		;Get the digit
   018d   fb 51          	xri	$51		;is it = "-" ?
   018f   32 9c          	bz	MINUS
                        
   0191   8a            	glo	ra		;Get the digit
   0192   fb 52         	xri	$52		; is it = "+" ?
   0194   32 98         	bz	PLUS		; Yes it is
                        
                        
   0196   30 77         	br	CLRCH		; No anything else - Just clear it
   0198                 PLUS:
   0198   f8 20         	LDI	$20		;write center vert line [|]for "+"
   019a   30 9e         	BR 	WS000
   019c                 MINUS:
   019c   f8 00         	LDI	$00		;CLEAR ALL for "-" or unknown
                        
                        ;****************NOTE: **************************
                        ;Almost the same as DISPCH but puts fixed patterns 
                        ;at location R(4) on the screen vs. from a table...
                        ;also the number of lines must be set 
                        ;****************NOTE: **************************
                        	
   019e                 WS000:			;
   019e   a5            	plo	r5		; fixed pattern is in R5.0
                        				;
   019f                 WS001:
   019f   85            	glo	r5		;max count is set above...
   01a0   54            	str	r4		;put  fixed pattern on screen
   01a1   84            	glo	r4		;point to next TV line 
   01a2   fc 08         	adi	$08		;this points to the byte directly below the last
   01a4   a4            	plo	r4		;on the TV screen
                        
   01a5   28            	dec	r8		;next lines (5 lines high)
   01a6   88            	glo	r8		;All lines filled (or cleared)
   01a7   32 ab         	bz	WS002		;Yes -> done with lines
   01a9   30 9f         	br 	WS001		;No -> next line
                        
   01ab                 WS002:
   01ab   84            	glo	r4		;fix pozition
   01ac   fc f8         	adi	$F8
   01ae   a4            	plo	r4
                        
   01af   8a            	glo	ra		;Get the digit
   01b0   fb 51          	xri	$51		;is it = "-" ?
   01b2   32 b9          	bz	WSBAR		;needs a bar
                        
   01b4   8a            	glo	ra		;Get the digit
   01b5   fb 52         	xri	$52		; is it = "+" ?
   01b7   3a 3a         	bnz 	L0080		;no then just blank -> next digit
                        	
                        
                        ; for a sign always put a cross bar up two lines
                        
   01b9                 WSBAR:
   01b9   84            	glo	r4		;point to last TV line 
   01ba   fc f0         	adi	$F0		;move to the 2 (3?) lines above the last (-24)Was E8
   01bc   a4            	plo	r4		;line on the TV screen
   01bd   f8 f8         	ldi	$F8		;[-] pattern
   01bf   54            	str	r4		;put it on screen
   01c0   84            	glo	r4
   01c1   fc 10         	adi	$10		;Put the index back? was 18
   01c3   a4            	plo	r4		;yup.
   01c4   30 3a         	br 	L0080		;DONE! get next digit
                        
                        
                        ;************************NOT USED IN THIS VERSION***************************************
                        ;This is the table of locations we will pick up and store the digits for display on the 
                        ;TV screen They are defined in DSKY pattern and should not change.  these are the locations
                        ;for V35N16 in AGC running PROG00 - this will display all the regs
                        ;************************NOT USED IN THIS VERSION***************************************
                        
                        ;VIDEO_OFFSET:
                        ;	DB	LOW DSKY_L1+2	; A.1 = 0202 (PROG ACTY) 
                        ;	DB	LOW DSKY_L1+5	; P.1
                        ;	DB	LOW DSKY_L1+6	; P.0
                        
                        ;	DB	LOW DSKY_L2+2	; VERB.1
                        ;	DB	LOW DSKY_L2+3	; VERB.0
                        ;	DB	LOW DSKY_L2+5	; NOUN.1
                        ;	DB	LOW DSKY_L2+6	; NOUN.0
                        
                        ;	DB	LOW DSKY_R1+5	;10HR
                        ;	DB	LOW DSKY_R1+6	;01HR
                        ;	DB	LOW DSKY_R2+5	;10MIN
                        ;	DB	LOW DSKY_R2+6	;01MIN
                        ;	DB	LOW DSKY_R3+3	;10SEC
                        ;	DB	LOW DSKY_R3+4	;01SEC
                        ;************************NOT USED IN THIS VERSION***************************************
                        
   01c6                 VIDEO_LINE:
   01c6   01            	DB	LOW DSKY_L1+1	;+1 to skip first column
   01c7   31            	DB	LOW DSKY_L2+1
   01c8   71            	DB	LOW DSKY_R1+1
   01c9   a1            	DB	LOW DSKY_R2+1
   01ca   d1            	DB	LOW DSKY_R3+1
                        
                        ;*********************************************************************************
                        ; 1861 DISPLAY INTERRUPT
                        ;*********************************************************************************
                        ; Description:
                        ; interrupt routine for 64x32 format (1 page display memory)  
                        ; Output 1: disable graphics, input 1: enable graphics, EF 1: in frame indicator              
                        ;
                        ;Registers Used:
                        ;	R(0) = DMA pointer
                        ;	R(1) = IRQ vector pointer
                        ;	R(2) = STACK pointer
                        ;	R(9) = Counter (1/61 Sec)
                        ;Hardware:
                        ;	EF1 = In-Frame indicator
                        ;
                        ;**********************************************************************************
   01cb                 TV_INT_ret:
   01cb   72            	ldxa		;-> RETURN FROM INTERRUPT (restore pointer)
   01cc   70            	ret
                        ;
   01cd                 TV_INT:		;<-Entry on INT
   01cd   c4            	nop		;Sync
   01ce   22            	dec	r2	;point to free location on stack	
   01cf   78            	sav		;push T
   01d0   22            	dec	r2
   01d1   52            	str	r2	;save D
                        
   01d2   e2            	sex	r2	;Cycles for timing
   01d3   e2            	sex	r2	;Set D=line start address (6 cycles)
                        
   01d4   19            	inc	r9	;increment at 1/61 sec count
                        
   01d5   f8 05         	ldi	HIGH DSKY_L1	; Point to Page # of VIDEO DISP
   01d7   b0            	phi	r0			; display RAM
   01d8   f8 00         	ldi	$00
   01da   a0            	plo	r0
   01db                 L009A:
   01db   80            	glo	r0	;1861 displays a line 1st time (8 cycles)
   01dc   e2            	sex	r2	;SYNC
   01dd   e2            	sex	r2	;reset line start address (6 cycles)
   01de   20            	dec	r0
                        			;1861 displays line 2nd time (8 cycles)
   01df   a0            	plo	r0
   01e0   e2            	sex	r2
   01e1   20            	dec	r0
                        			;1861 displays line 3rd time (8 cycles)
   01e2   a0            	plo	r0
   01e3   e2            	sex	r2	;reset line start address (6 cycles)
   01e4   20            	dec	r0	;
                        
   01e5   a0            	plo	r0
   01e6   3c db         	bn1	L009A			;Keep looping until EF1 = 1 (loops 32 times)
                        
   01e8   30 cb         	br	TV_INT_ret		;Exit on top to restore pointer	
                        	
                        ;=========================================================================
                        ;=============================PAGE 0200===================================
                        ;=========================================================================
                        
   0200                 	org	$0200
                        
                        ;************************************************************************
                        ; 						VIP_KY
                        ;************************************************************************
                        ;Description: This is the KeY part of DSKY. Since COSMAC VIP only has 16
                        ; keys, some are reused  The secondary command keys (& Key) are contextual
                        ; depending on what state the key command processor is in.
                        ; 
                        ;Use: This computer use a series of commands in the format
                        ; 	Vxx <Enter>  Nxx <enter>
                        ; 
                        ;EXAMPLES:
                        ;  "A", (V1V2 go blank) V1, V2,"C"(Clear: start over), V1, V2... 
                        ;  "E" (Enter: Saves it)
                        ;    -> if a "D" is entered before "E" the original V1V2 will remain...
                        ;    -> if no NOUN is needed "E" will run the VERB command
                        ;    -> if a NOUN is needed N1N2 will flash until a "B" or "D" is entered ...
                        ;   "B", (N1N2 go blank) N1, N2..as before with VERBs "E" (Enter: Saves it)
                        ;    -> if the V+N is not known both will flash 
                        ;    -> If P1 P2 flash indicates another prog needs the display (except idle?)
                        ;   "D" will release the display to that prog.
                        ;
                        ;************************************************************************
                        
                        
                        ;****************************************************************
                        ; COMMAND PROCESSING (PINBALL)
                        ;****************************************************************
                        ;PURPOSE:
                        ;
                        ;Test for the 6 non-numeric (HEX) keys:
                        ;A = VERB
                        ;B = NOUN
                        ;C = REL/Clear
                        ;D = PROCEED
                        ;E = Enter 
                        ;F = +/-
                        ;
                        ;Enter: with found key in RE
                        ;Exit: command 
                        ;REGISTERS USED:
                        ;
                        ;  R(3) = Calling PC (Do not change!)
                        ;  R(4) = Mem Pointer (X)
                        ;  R(5) = Mem Pointer (Storage pointer)
                        ;  R(D) = prog counter
                        ;  R(E) = Character found by key 
                        
                        ;****************************************************************
                        
   0200                 CPRET:
   0200   d3            	sep	r3
   0201                 CPROC:
   0201   8e            	glo	re
   0202   fa 0f         	ani	$0f	;Mask any control bits
   0204   ae            	plo	re	;save the key for test
                        
   0205   8e            	glo	re
   0206   fb 0a         	xri	$0A	;A = VERB
   0208   32 25         	bz	VERBS	
                        
   020a   8e            	glo	re
   020b   fb 0b         	xri	$0B	;B = NOUN
   020d   32 2d         	bz	NOUNS
                        
   020f   8e            	glo	re
   0210   fb 0c         	xri	$0C	;C = CLEAR or REL
   0212   32 4f         	bz	CONS
                        
   0214   8e            	glo	re
   0215   fb 0d         	xri	$0D	;D = PROCEED
   0217   32 5c         	bz	PROS
                        	
   0219   8e            	glo	re
   021a   fb 0e         	xri	$0E	;E = Enter
   021c   32 83         	bz	ENTER
                        
   021e   8e            	glo	re
   021f   fb 0f         	xri	$0F	;F = +/-
   0221   32 ab         	bz	SIGNS
                        
   0223   30 cb          	br	NOHEX ;(return)
                        ;	br	CPRET		
   0225                 VERBS:
   0225   f8 00         	ldi	HIGH NOUN_VERB	;Get the pointer to Verb Reg
   0227   b4            	phi	r4			;to R(4.1)
   0228   f8 a8         	ldi	LOW NOUN_VERB+1
   022a   a4            	plo	r4			;to R(4.0)
   022b   30 33         	br 	NV001
   022d                 NOUNS:
   022d   f8 00         	ldi	HIGH NOUN_VERB
   022f   b4            	phi	r4
   0230   f8 ab         	ldi	LOW NOUN_VERB+4
   0232   a4            	plo	r4			;to R(4.0)
                        
   0233                 NV001:
   0233   04            	ldn	r4	;get first digit M[R(4)] -> D
   0234   fa 0f         	ani	$0f	;Mask any control bits
   0236   fc c0         	adi	$C0	;Set to flash (or clear) 
   0238   54            	str	r4
   0239   14            	inc	r4	;get next digit 
   023a   04            	ldn	r4
   023b   fa 0f         	ani	$0f	;Mask any control bits
   023d   fc c0         	adi	$C0
   023f   54            	str	r4	
                        
                        
                        ; this section was put in to stop flash on NN
                        ; not needed *ONLY for test*
                        
                        ;	ldi	LOW NOUN_VERB+4 ; Point to Nouns;
                        ;	plo	r4
                        ;	ldn	r4		;get N1.1
                        ;	ani	$0F		;Clear any control bits
                        ;	str	r4
                        ;	inc	r4		;...and N1.0
                        ;	ldn	r4
                        ;	ani	$0F	
                        ;	str	r4
                        
                        ;===========================================================
                        ;CMD byte works like this:
                        ;===========================================================
                        ;(1) the hex DIGIT is the CMD to execure a command process. 
                        ; The command process follows this process so all HEX chars 
                        ; are filtered and only digits will be used.
                        ;(2) As the command processed it takes needed digits
                        ; and puts them in registers, pointed to by the base CMD
                        ; it only puts chars in slots with control nibbles
                        ; 0xFn, 0xCn etc.  The new digit overwrites the control,
                        ;if the slot has no control it skips to next reg.
                        ;(3) CMD then gets cleared so no further processing takes 
                        ;place...i.e. digits with no where to go get ignored!
                        ;===========================================================
                        
   0240   f8 00         	ldi	HIGH CMD	;put in CMD storage (PAGE 0)
   0242   b5            	phi	r5		;Index in R(4.1)
   0243   f8 98         	ldi	LOW CMD	;put in CMD storage 
   0245   a5            	plo	r5		;Index in R(4,0)
   0246   8e            	glo	re		;Verb or Noun Command 
   0247   55            	str	r5
                        ;///NEW///
   0248   f8 9a         	ldi	LOW CCNT	;Make sure we are not storing digits
   024a   a5            	plo	r5	
   024b   95            	ghi	r5		;should be 0
   024c   55            	str	r5
                        ;///NEW///
   024d   30 00         	br	CPRET	
                        
                        
                        ;************************************************
                        ;*************[C] CLEAR KEY**********************
                        ;************************************************
                        ;USE: This key clears the current register 
                        ;it Restarts the last input "2x" command in VERB  
                        ;the display gets clear and restarts the REG line.
                        ;************************************************
                        
   024f                 CONS:
   024f   f8 04         	ldi	HIGH CFLASHVN
   0251   bd            	phi	rd
   0252   f8 ab         	ldi	LOW CFLASHVN	; 
   0254   ad            	plo	rd	
   0255   dd            	sep	rd
                        
   0256   f8 ca         	ldi	LOW SAVTIME
   0258   ad            	plo	rd	
   0259   dd            	sep	rd
                        
   025a   30 00         	br	CPRET		;No -  just exit
                        ;	br	ENTER		;Reset the line	
                        
                        ;************************************************
                        ;*************[D] PROCEED KEY********************
                        ;************************************************
                        ;This key kills the last command in VERB+1 
                        ;so the display gets returned to the original task.
                        ;in VERB+0.  It should also clear the warning indic
                        ;and any flashing VERB/NOUN +-
                        ;NOTE: V33E does the same thing...
                        ;
                        ;*************************************************
                        
                        
   025c                 PROS:
   025c   f8 c0         	ldi	LOW VERB+1		; CLEAR VERB+1 (last command running)
   025e   a5            	plo	r5
   025f   f8 00         	ldi	HIGH $00		;these are on page 0
   0261   b5             	phi	r5
   0262   55            	str	r5
   0263   f8 c2         	ldi	LOW NOUN+1		;Clear that Noun too.
   0265   a5            	plo	r5
   0266   55            	str	r5
                        
   0267   f8 a8         	ldi	NOUN_VERB+1	;If Recent TEST LAMPS
   0269   a4            	plo	r4			;YES- "D" KEY will stop it now
   026a   04            	ldn	r4	
   026b   fb f8         	xri	$F8		;Yes- CLEARS the ALL BALLS NOUN
   026d   32 71         	bz	CLRTST	;are we doing a lamp test?
   026f   30 00         	br	CPRET		;No -  just exit
                        
   0271                 CLRTST:			
                        ;	ldi	$00
   0271   54            	str	r4		;R(4) should be pointing to VERB
   0272   14            	inc	r4		;CLEARS the ALL BALLS in VERB	
   0273   54            	str	r4
                        
   0274   14            	inc	r4		
   0275   14            	inc	r4	
   0276   54            	str	r4
   0277   14            	inc	r4	
   0278   54            	str	r4
                        
   0279   f8 a5         	ldi	PROG_REG+4	;Point to prog
   027b   a4            	plo	r4
                        
   027c   f8 00         	ldi	$00		;ZERO to PROG
   027e   54            	str	r4
   027f   14            	inc	r4	
   0280   54            	str	r4
   0281   30 00         	br	CPRET	
                        
                        
                        
                        ;************************************************
                        ;*************[E] ENTER KEY**********************
                        ;************************************************
                        ;(1)Assemble VERB and NOUN Bytes and flag to 
                        ;execute! putting a non-zero in the VERB will be 
                        ;the FLAG for it to run
                        ;(2) Also used to {E}nter the REG line in 2N VERBs
                        ;************************************************
   0283                 ENTER:
   0283   f8 04         	ldi	HIGH CFLASHVN
   0285   bd            	phi	rd
   0286   f8 ab         	ldi	LOW CFLASHVN	; 
   0288   ad            	plo	rd	
   0289   dd            	sep	rd
                        ;this is to store REG will go here
                        ;	
                        ;	ghi	r5		;should be 0
                        ;;	str	r5
                        ;	br	CPRET	
   028a                 ASSEM:
   028a   f8 00         	ldi	HIGH $00		;these are on page 0
   028c   b5             	phi	r5
   028d   f8 a8         	ldi	LOW NOUN_VERB+1	; Get current VERB Nybbles
   028f   a5            	plo	r5
   0290   f8 bf         	ldi	LOW VERB		; VERB storage 
   0292   a4            	plo	r4
   0293   e5            	sex	r5
                        ;assemble the VERB
   0294   72            	LDXA			;load via R5(X) -> X+1 point to next
   0295   fe            	shl             ;shift it into high nibble
   0296   fe            	shl
   0297   fe            	shl	
   0298   fe            	shl
   0299   f1            	or			;combine nibbles
   029a   54            	str	r4		;store via R(4)
                        
                        ;assemble the NOUN
   029b   f8 ab         	ldi	LOW NOUN_VERB+4	; Get current VERB Nybbles
   029d   a5            	plo	r5
   029e   f8 c1         	ldi	LOW NOUN		; NOUN storage 
   02a0   a4            	plo	r4
   02a1   72            	LDXA
   02a2   fe            	shl             	;shift it into high nibble
   02a3   fe            	shl
   02a4   fe            	shl	
   02a5   fe            	shl
   02a6   f1            	or
   02a7   54            	str	r4		;store via x
   02a8   e2            	sex	r2		;Reset X
                        
                        
   02a9   30 00         	br	CPRET	
                        ;************************************************
                        ;*************[F] +/-SIGN KEY********************
                        ;************************************************
                        ;Processes the a change of SIGN
                        ;Pressing the F key cycles thru all combinations
                        ;of the SIGN in the REGisters it only works on
                        ;digits that have 5X Control byte set. 
                        ;************************************************
                        
   02ab                 SIGNS:
                        
   02ab   f8 00         	ldi	HIGH REG1 ; Let's use 1st sign for test....
   02ad   b4            	phi	r4
   02ae   b5            	phi	r5
   02af   f8 99         	ldi	LOW CDEX
   02b1   a5            	plo	r5
                        
   02b2   05            	ldn	r5		; get the digit pointer
   02b3   a4            	plo	r4
   02b4   04            	ldn	r4		;pick up the current char
                        	
   02b5   fa f0         	ani	$f0		; mask off type
   02b7   fb 50         	xri	$50		;are you really a sign?
   02b9   3a 00         	bnz	CPRET 	;NO - then i don't care
                        
   02bb   04            	ldn	r4		;YES- increment the current sign
   02bc   fc 01         	adi	$01		; increment
   02be   fa f3         	ani	$F3		;mask off 1111 0011 for rollover
   02c0   54            	str	r4		;put new sign back to (M)[ R(4) ]
                        
   02c1   04            	ldn	r4		;was this the 4th count?
   02c2   fb 53         	xri	$53		;need to Get rid of extra key stroke
   02c4   3a 00         	bnz	CPRET		;no -  we are good
                        
   02c6   f8 50         	ldi	$50		;yes - back to zero!
   02c8   54            	str	r4		;
   02c9   30 00         	br	CPRET	
                        
                        ;So now that we sorted all possible HEX - it must be a digit
                        ;but we need tocheck to see if a command needs a digit...
                        
   02cb                 NOHEX:
                        
                        
                        ;Check if we need to store a register digit
   02cb   f8 9a         	ldi	LOW CCNT	;Do We need a DIGIT in REG?
   02cd   a5            	plo	r5			;to R(5.0)
   02ce   f8 00         	ldi	HIGH CCNT	;Do We need a DIGIT in REG?
   02d0   b5            	phi	r5			;to R(5.1)
   02d1   05            	ldn	r5
                        
   02d2   32 dd         	bz	VNCMD		;No - check for VERB or NOUN
                        	
   02d4                 GETDIG:
   02d4   f8 25         	ldi	LOW WRDEC	;Yes - store it in REG RxDx	
   02d6   ad            	plo	rd
   02d7   f8 04         	ldi	HIGH WRDEC
   02d9   bd            	phi	rd
   02da   dd            	sep	rd
   02db   30 00          	br	CPRET
                        ;
                        
   02dd                 VNCMD:
                        	;////////NEW///////
   02dd   f8 4d         	ldi	LOW CHKCMD	;Yes - store it in REG RxDx	
   02df   ad            	plo	rd
   02e0   f8 04         	ldi	HIGH CHKCMD
   02e2   bd            	phi	rd
   02e3   dd            	sep	rd
                        
   02e4   30 00          	br	CPRET
                        	;////////NEW///////
                        ;
                        ;=========================================================================
                        ;=============================PAGE 0300===================================
                        ;=========================================================================	
   0300                 	org	$0300	
                        ;************************************************************************
                        ; CMD_PROC  - This page does stuff
                        ;************************************************************************
                        ;The command processor detrmines what is displayed. Each display state is
                        ;Based on the V+N entered by the KEY commands, switch statement jumps to
                        ;active process.  The RTC runs in the background updated by the video interrupt
                        ;from the PIXIE display runs in background all the time the user can choose to 
                        ;show the time (MET or RTC)  or do a couple other things. Not all the 
                        ;AGC commands work, the ones not implemented will be ignored.
                        ;These are to be implemented (demonstrated):
                        ;
                        ;	COMMAND	DISCRIPTION
                        ;Set DECIMAL Commands:
                        ;	V21NxxE =	Enter DECIMAL in R1
                        ;	V22NxxE =	Enter DECIMAL in R2
                        ;	V23NxxE =	Enter DECIMAL in R3
                        ;	V25N36E = 	Set Clock (SET TIME = RTC)
                        ;Test Commands:
                        ;	V35E = 	Lamp test (LAMPS)
                        ;	V36E = 	Clear Displays (CLEAR)
                        ;	V37E00E = 	Program 0 (P00h) Note: N00E can be 00 - 99
                        ;Monitor R1, R2, R3 in Decimal
                        ; 	V16N65E = 	Mission Elapsed Time(MET) 
                        ;	V16N36E = 	Real Time Clock (RTC) 
                        ;************************************************************************	
                        
                        ;***************************NOTE**************************************	
                        ;There may also be a fictious command soon:
                        ;	V20N15E = 	YEAR (YY = 15 will update to next year after 365(6) 
                        ;	This causes the days counter on REG1  to update as well as 
                        ;	the MET clock.  It also incremente PROG 0 -> 7 (Day of week) and
                        ;	the day counter resets at 365 and 366 on the next several LYs
                        ;	Note: if you use this as a clock for several years you will burn
                        ;	the display!
                        ;***************************NOTE**************************************	
                        
                        
   0300                 AGC_RET:
   0300   d3            	sep	r3		;all done with AGC result display to process
   0301                 AGC_PROC1:
   0301   f8 00         	ldi	$00		;all registers are on PAGE 0
   0303   b4            	phi	r4
   0304   b5            	phi	r5
                        
   0305   f8 bf         	ldi	LOW	VERB	; Get the current verb
   0307   a4            	plo	r4
   0308   04            	ldn	r4
   0309   32 00         	bz	AGC_RET	;nothing get out of processing
                        
   030b   fb 16         	xri	$16		;VERB 16 =  Decimal Display R1,R2, R3 
   030d   32 2a         	bz	V16
                        	
   030f   04            	ldn	r4
   0310   fb 21         	xri	$21		; VERB 21 = Decimal LOAD R1
   0312   32 81         	bz	V21
                        
   0314   04            	ldn	r4
   0315   fb 22         	xri	$22		; VERB 22 = Decimal LOAD R2 
   0317   32 85         	bz	V22
                        
   0319   04            	ldn	r4
   031a   fb 23         	xri	$23		; VERB 23 = Decimal LOAD R3 
   031c   32 89         	bz	V23
                        
   031e   04            	ldn	r4
   031f   fb 35         	xri	$35		; VERB 35 = LAMP TEST
   0321   32 c9         	bz	V35
                        
   0323   04            	ldn	r4
   0324   fb 36         	xri	$36		; VERB 36 = set all REG to 0
   0326   32 2f         	bz	V36
                        		
   0328   30 aa         	br	NOGO	; not a known process
                        
                        ;**************VERB 16**********************
                        ;Moves the counters to display for V=16 N=35E
                        ;Moves the counters to display for V=16 N=65E
                        ;from Mission Elapse Time (MET) counters on 
                        ;Page 0000 to show Real Time Clock on the DSKY
                        ;
                        ;********************************************
   032a                 V16:
   032a   f8 00         	ldi	$00	;Put ZEROs in
   032c   af            	plo	rf
   032d   30 32         	br	CLR3	;clear all 
                        
                        ;**************VERB 36**********************
                        ;Clears all the displays 
                        ;********************************************
   032f                 V36:
                        ;..............NOTE.............
                        ;need to clear the signs still
                        ;..............NOTE.............
                        
   032f   f8 c0         	ldi	$C0	;Put CLEARs in 
   0331   af            	plo	rf
                        
   0332                 CLR3:
                        ;Set all REGs
   0332   f8 01         	ldi	LOW	SET3
   0334   ac            	plo	rc
   0335   f8 04         	ldi	HIGH	SET3
   0337   bc            	phi	rc
                        
                        
   0338   f8 b9         	ldi	LOW	REG3	;Set REG3
   033a   dc            	sep	rc
                        
   033b   f8 b3         	ldi	LOW	REG2	;Set REG2
   033d   dc            	sep	rc
                        
   033e   f8 ad         	ldi	LOW	REG1	;Set REG1
   0340   dc            	sep	rc
                        
   0341   f8 00         	ldi	HIGH	VERB	;make Same page 0 (needed?)
   0343   b4            	phi	r4
   0344   f8 bf         	ldi	LOW	VERB	; Get the current verb
   0346   a4            	plo	r4
                        
   0347   04            	ldn	r4		;get current VERB
   0348   fb 36         	xri	$36		;was it VERB 36?
   034a   3a 60         	bnz	CHK_NOUNS	;No - Check some nouns... 
   034c   f8 00         	ldi	$00		;Yes - Clear the VERB
   034e   54            	str	r4
   034f   14            	inc	r4
   0350   14            	inc	r4
   0351   54            	str	r4
                        
   0352   f8 a8         	ldi	LOW	NOUN_VERB+1 ; "00" -> VERB
   0354   a4            	plo	r4
   0355   94            	ghi	r4
   0356   54            	str	r4
   0357   14            	inc	r4
   0358   54            	str	r4
                        
   0359   14            	inc	r4	; "00" -> VERB	
   035a   14            	inc	r4	
   035b   54            	str	r4
   035c   14            	inc	r4	
   035d   54            	str	r4
                        
   035e   30 00         	br	AGC_RET	;Done -> Exit
                        
   0360                 CHK_NOUNS:
   0360   f8 c1         	ldi	LOW	NOUN	; Get the current noun
   0362   a4            	plo	r4
                        
   0363   04            	ldn	r4
   0364   fb 36         	xri	$36		;NOUN 36?
   0366   32 6f         	bz	LOAD_MET	;YES -> get RTC
                        
   0368   04            	ldn	r4
   0369   fb 65         	xri	$65		;NOUN = 65?
   036b   32 6f         	bz	LOAD_MET	;YES -> Get MET
                        
                        ;..............NOTE.....................................
                        ;If we don't clear VERB here we can keep entering nouns.
                        ;and don't consider it an error... and start flashing
                        ;we can just exit here
                        ;..............NOTE.....................................
                        
   036d   30 00         	br	AGC_RET	;Every other NOUN -> Exit
                        
                        	
   036f                 LOAD_MET:
   036f   f8 9b          	ldi	LOW HHMMSS ;No, Load source is clock
   0371   a4             	plo	r4
   0372   f8 db         	ldi	LOW MET_OFFSETS	;destination is REG1 - REG3
   0374   a5            	plo	r5
                        
                        
   0375                 NEXT_DIG:
                        
   0375   05            	ldn	r5		;get the display pointer
   0376   a6            	plo	r6		;R6.0
   0377   72            	ldxa			;Pick up HHMMSS digit, increment index  X+1
   0378   56            	str	r6		;store them in register locations
                        ;	
   0379   15            	inc	r5			; point to next
   037a   84            	glo	r4			;test for done with moves
   037b   fb a1         	xri	LOW HHMMSS+6 
   037d   3a 75         	bnz	NEXT_DIG		;nope - get next one
                        
   037f   30 00         	br	AGC_RET
                        
                        ;**************VERB 21**********************
                        ;Clear R1 ($0xC0->R1D1 to R1D5)
                        ;Set Sign 
                        ;Load DECIMAL into R1D1 -> R1D5
                        ;
                        ;********************************************
   0381                 V21:
   0381   f8 ad         	ldi	LOW	REG1
   0383   30 8b         	br	V2N
                        
                        ;**************VERB 22**********************
                        ;Load DECIMAL into R2D1 -> R2D5
                        ;SAME AS ABOVE
                        ;*******************************************
   0385                 V22:
   0385   f8 b3         	ldi	LOW	REG2
   0387   30 8b         	br	V2N
                        
                        ;**************VERB 22**********************
                        ;Load DECIMAL into R3D1 -> R3D5
                        ;SAME AS ABOVE
                        ;*******************************************
   0389                 V23:
   0389   f8 b9         	ldi	LOW	REG3
                        
   038b                 V2N:
   038b   a4            	plo	r4
   038c   f8 00         	ldi	$00
   038e   b4            	phi	r4
   038f   b5            	phi	r5
                        
   0390   f8 99         	ldi	LOW	CDEX	;put the index in memory for later
   0392   a5            	plo	r5
   0393   84            	glo	r4
   0394   55            	str	r5
                        
   0395   f8 50         	ldi	$50	;clear the sign
   0397   54            	str	r4
   0398   14            	inc	r4
                        
                        ;Load the counter - NOTE that this is also the flg to process
   0399   f8 9a         	ldi	LOW CCNT
   039b   a6            	plo	r6	;use as mem pointer 
   039c   f8 05         	ldi	$05	;char count -> CCNT (sign+5 digits)
   039e   a5            	plo	r5	;loop counter = R5
   039f   56            	str	r6	;M[R6] = CCNT 
                        
   03a0                 V2XCLRL:			;clear the register 
   03a0   f8 c0         	ldi	$C0		;Clear command
   03a2   54            	str	r4
   03a3   14            	inc	r4
   03a4   25            	dec	r5		;Decrement Loop Count
   03a5   85            	glo	r5
   03a6   3a a0         	bnz	V2XCLRL
                        
   03a8   30 ba         	br	CLRVN		;Done with this verb
                        	
                        
   03aa                 NOGO:
                        ;assuming still  PAGE 0000 here...
                        
   03aa   f8 a8         	ldi	LOW NOUN_VERB+1
   03ac   a4            	plo	r4			;to R(4.0)
                        
   03ad   04            	ldn	r4	;get first digit M[R(4)] -> D
   03ae   fa 0f         	ani	$0f	;Mask any control bits
   03b0   fc f0         	adi	$F0	;Set to flash 
   03b2   54            	str	r4
   03b3   14            	inc	r4	;get next digit 
   03b4   04            	ldn	r4
   03b5   fa 0f         	ani	$0f	;Mask any control bits
   03b7   fc f0         	adi	$F0
   03b9   54            	str	r4
                        
   03ba                 CLRVN:	
   03ba   f8 bf         	ldi	VERB	;Done- clear out old verb
                        
   03bc   a4            	plo	r4
   03bd   f8 00         	ldi	$00
   03bf   54            	str	r4
                        ;//NEW
   03c0   f8 88         	ldi	LOW FLASHVN
   03c2   ac            	plo	rc
   03c3   f8 04         	ldi	HIGH FLASHVN
   03c5   bc            	phi	rc
   03c6   dc            	sep	rc
                        
   03c7   30 00         	br	AGC_RET
                        
   03c9                 V35:
   03c9   f8 01         	ldi	LOW	SET3
   03cb   ac            	plo	rc
   03cc   f8 04         	ldi	HIGH	SET3
   03ce   bc            	phi	rc
                        
   03cf   f8 08         	ldi	$08	;<<<this can be changed to use a variable
   03d1   af            	plo	rf
                        
   03d2   f8 b9         	ldi	LOW	REG3	;Set REG3
   03d4   dc            	sep	rc
                        
   03d5   f8 b3         	ldi	LOW	REG2	;Set REG2
   03d7   dc            	sep	rc
                        
   03d8   f8 ad         	ldi	LOW	REG1	;Set REG1
   03da   dc            	sep	rc
                        
   03db   f8 bf         	ldi	VERB	;TESTVERB LAMPS
   03dd   a4            	plo	r4
   03de   f8 88         	ldi	$88
   03e0   54            	str	r4
                        
   03e1   f8 a8         	ldi	NOUN_VERB+1
   03e3   a4            	plo	r4
   03e4   f8 f8         	ldi	$F8	;flashing 88 in VERB
   03e6   54            	str	r4
   03e7   14            	inc	r4
   03e8   54            	str	r4
                        
   03e9   14            	inc	r4	;Point to NOUN
   03ea   14            	inc	r4	
   03eb   54            	str	r4
   03ec   14            	inc	r4	
   03ed   54            	str	r4
                        
   03ee   f8 a5         	ldi	PROG_REG+4	;Point to prog
   03f0   a4            	plo	r4
                        
   03f1   f8 f8         	ldi	$F8	;flashing 88 in PROG
   03f3   54            	str	r4
   03f4   14            	inc	r4	
   03f5   54            	str	r4
                        
   03f6   30 00         	br	AGC_RET
                        
                        
                        ;=========================================================================
                        ;=============================PAGE 0400===================================
                        ;=========================================================================
   0400                 	org	$0400
                        
                        ;*********************************************************************
                        ;                      SUBROUTINE: SET3
                        ;*********************************************************************
                        ;USE: Load  Registers SUBR
                        ;
                        ;CDEX= REG Addr (on PAGE 0)
                        ;R(C) = PC
                        ;R(D) = CALLING PC (Don't Use)
                        ;*********************************************************************
   0400                 SET3_RET:
   0400   dd            	sep	rd	;Restore CALLING PC
   0401                 SET3:
   0401   a4            	plo	r4	;Register address in POINTER
   0402   f8 00         	ldi	$00	;Assuming PAGE 0
   0404   b4            	phi	r4
   0405   b5            	phi	r5
   0406   f8 99         	ldi	LOW	CDEX	; Character Pointer on PAGE 0
   0408   a5            	plo	r5
   0409   84            	glo	r4
   040a   55            	str	r5
                        
                        ;DO the SIGN for this REG..	
   040b   8f            	glo	rf
   040c   fb c0         	xri	$C0
   040e   3a 14         	bnz	SETPLS
   0410   f8 50         	ldi	$50		;CLR Sign
   0412   30 16         	br	SETCLR
   0414                 SETPLS:
   0414   f8 52         	ldi	$52		;set (+) Sign
   0416                 SETCLR:
   0416   54            	str	r4
   0417   14            	inc	r4
                        
                        ;SET the rest of the five digits in the REG
   0418   f8 05         	ldi	$05	;char counter
   041a   a5            	plo	r5
                        	
                        
   041b                 S3LOOP:			;clear the register 
                        ;	ldi	$08	;<<<this can be changed to use a variable
   041b   8f            	glo	rf
   041c   54            	str	r4
   041d   14            	inc	r4
   041e   25            	dec	r5
   041f   85            	glo	r5
   0420   3a 1b         	bnz	S3LOOP	;all 5 set?
   0422   30 00         	br	SET3_RET	;yes! Done RETURN
                        
                        ;*********************************************************************
                        ;                      SUBROUTINE: WRDEC
                        ;*********************************************************************
                        ;USE: Load DECIMAL Register SUBR
                        ;CALL: From NO HEX (Only digits 0 -9 should be passed 
                        ;CDEX = REG Addr (on PAGE 0)
                        ;CCNT = COUNTER Addr (on PAGE 0)
                        ;R(D) = PC
                        ;R(C) = CALLING PC (Don't Use)
                        ;R(4) = MEMORY location for INDEX
                        ;R(6) = INDEX pointer REG
                        ;R(5) = MEMORY location for COUNTER
                        ;R(7) = COUNTER REG
                        ;
                        ;MEMORY STORAGE:
                        ;CDEX = Pointer to Current Register location
                        ; If it is 0\clear we don't need any digits
                        ; if M(RX) = $Cx then store
                        ; DEC CCNT
                        ; IF CCNT = 0 then done
                        ;CCNT = Counter 5 -> 0 
                        ; 
                        ;*********************************************************************
   0424                 RET_WRDEC:
   0424   dc            	sep	rc
   0425                 WRDEC:
   0425   f8 00         	ldi	HIGH CDEX	;Get the REG pointer to RegN
   0427   b4            	phi	r4			;to R(4.1)
   0428   b5            	phi	r5			;to R(5.1)
   0429   b6             	phi	r6			;to R(6.1)
   042a   f8 99         	ldi	LOW CDEX	;index storage
   042c   a4            	plo	r4			;to R(4.0)
   042d   a6            	plo	r6		;index
                        
                        ;	ldi	HIGH CCNT	;Get the REG Counter ->Page Zero?
                        ;	phi	r5
                        			;to R(5.1)
   042e   f8 9a         	ldi	LOW CCNT
   0430   a5            	plo	r5			;to R(5.0)
   0431   05            	ldn	r5
   0432   a7            	plo	r7
   0433   32 24         	bz	RET_WRDEC		;all digits? Yes exit.
                        
   0435   06            	ldn	r6		;point to reg location
   0436   a6            	plo	r6
   0437   06            	ldn	r6		;now get current reg contents
   0438   fa f0         	ani	$F0		;
   043a   fb c0         	xri	$C0		; is the Space clear? 
   043c   32 3f         	bz	SAVDIG	;Yes - we can use it -> save it
   043e   16            	inc	r6		;No - this will skip over sign and digit
                        ;	dec	r7		;this may have been the last needed?
                        
   043f                 SAVDIG:
   043f   8e            	glo	re		;get the last key
   0440   56            	str	r6		;SAVE DIGIT NOW!
                        	
                        
   0441   16            	inc	r6		;point to next
   0442   86            	glo	r6
   0443   54            	str	r4		;put it in index storage
                        	
   0444   87            	glo	r7		;if it is already zero don't dec
   0445   32 24         	bz	RET_WRDEC
                        
   0447   27            	dec	r7		;Dec and Save the count
   0448   87            	glo	r7		;
   0449   55            	str	r5		;Save it in memory R7 -> M[R5]
   044a   30 24         	br	RET_WRDEC	;Done with this digit
                        
                        ;////////NEW///////
   044c                 CMRET:
   044c   dc            	sep	rc
   044d                 CHKCMD:
                        ;Check if we need a VERB or NOUN  Digit
   044d   f8 98         	ldi	LOW CMD	;CMD pointer 
   044f   a5            	plo	r5		;Index in R(5.0)
   0450   f8 00         	ldi	HIGH CMD	;CMD pointer 
   0452   b5            	phi	r5		;Index in R(5.1)
                        
   0453   05            	ldn	r5
   0454   32 4c         	bz	CMRET		; No command to process - check if data is needed
   0456   fb 0a         	xri	$0A
   0458   32 62         	bz	VERCMD	;VERB
                        
   045a   05            	ldn	r5
   045b   fb 0b         	xri	$0B
   045d   32 6a         	bz	NOUCMD	;NOUN
                        
   045f   f8 00         	ldi	$00	;clear it out if it was 
   0461   55            	str	r5	;not a known command...
                        
                        
                        
                        ;OK so we need a VERB Digit...
   0462                 VERCMD:
   0462   f8 00         	ldi	HIGH NOUN_VERB	;Get the pointer to Verb Reg
   0464   b4            	phi	r4			;to R(4.1)
   0465   f8 a8         	ldi	LOW NOUN_VERB+1
   0467   a4            	plo	r4			;to R(4.0)
   0468   30 70         	br	NVCM1
                        
                        ;OK so we need a NOUN Digit...
   046a                 NOUCMD:
   046a   f8 00         	ldi	HIGH NOUN_VERB
   046c   b4            	phi	r4
   046d   f8 ab         	ldi	LOW NOUN_VERB+4
   046f   a4            	plo	r4			;to R(4.0)
                        
   0470                 NVCM1:
   0470   04            	ldn	r4	;get the storage location
   0471   fa f0         	ani	$F0	;check to see if new digit is needed	
   0473   32 77         	bz	NEXNV	; no - control is clear so it is loaded
   0475   30 82         	br	WRTNV
                        
   0477                 NEXNV:
   0477   14            	inc	r4	;increment storage pointer
   0478   04            	ldn	r4	;get the next storage location
   0479   fa f0         	ani	$F0	; check for need...	
   047b   3a 82         	bnz	WRTNV	; yes control is there write new one
   047d   f8 00         	ldi	$00	; no control -  then we are done... 
   047f   55            	str	r5	; kill the command via CMD pointer
   0480   30 4c         	br	CMRET	
                        
   0482                 WRTNV:
   0482   8e            	glo	re	;finally, get our digit an put it in REG
   0483   fa 0f         	ani	$0F	; make double sure no control in MSB
   0485   54            	str	r4
   0486   30 4c         	br	CMRET
                        
   0488                 FLASHVN:
   0488   f8 00         	ldi	HIGH NOUN_VERB
   048a   b4            	phi	r4
   048b   f8 a8         	ldi	LOW NOUN_VERB+1
   048d   a4            	plo	r4
                        
   048e   04            	ldn	r4
   048f   fa 0f         	ani	$0f	;Mask any control bits
   0491   fc f0         	adi	$F0	;FLASH VERB MSB
   0493   54            	str	r4
                        
   0494   14            	inc	r4
   0495   04            	ldn	r4
   0496   fa 0f         	ani	$0f	;Mask any control bits
   0498   fc f0         	adi	$F0	;FLASH VERB LSB
   049a   54            	str	r4
                        
   049b   14            	inc	r4	;Point to NOUN
   049c   14            	inc	r4
   049d   04            	ldn	r4
   049e   fa 0f         	ani	$0F	;FLASH NOUN MSB
   04a0   fc f0         	adi	$F0
   04a2   54            	str	r4
                        
   04a3   14            	inc	r4	;FLASH NOUN LSB
   04a4   04            	ldn	r4
   04a5   fa 0f         	ani	$0F
   04a7   fc f0         	adi	$F0	
   04a9   54            	str	r4
                        
   04aa   dd            	sep	rd
                        
   04ab                 CFLASHVN:
                        
   04ab   f8 a8         	ldi	LOW NOUN_VERB+1	; Get current VERB Nybbles
   04ad   a5            	plo	r5	
   04ae   f8 00         	ldi	HIGH NOUN_VERB+1	; Get current VERB Nybbles
   04b0   b5            	phi	r5
                        	
   04b1   05            	ldn	r5	;Should be pointing to VERBs display 
   04b2   fa 0f         	ani	$0F	;Stop FLASH MSB
   04b4   55            	str	r5
   04b5   15            	inc 	r5
   04b6   05            	ldn	r5
   04b7   fa 0f         	ani	$0F	;Stop FLASH LSB
   04b9   55            	str	r5
                        	
   04ba   15            	inc	r5	;now point to NOUNs display
   04bb   15            	inc	r5
                        
   04bc   05            	ldn	r5
   04bd   fa 0f         	ani	$0F	;Stop FLASH MSB
   04bf   55            	str	r5
   04c0   15            	inc 	r5
   04c1   05            	ldn	r5
   04c2   fa 0f         	ani	$0F	;Stop FLASH LSB
   04c4   55            	str	r5
                        
   04c5   f8 a9         	ldi	LOW NOUN_VERB+2	; Get current VERB Nybbles
   04c7   a5            	plo	r5
   04c8   05            	ldn	r5
                        
   04c9   dc            	sep	rc
                        
                        ;	ldi	LOW REG1+4	;Hours
                        ;	ldi	LOW REG3+2	;Sec
                        ;SAVMN:
                        ;	ldi	LOW REG2+4	;Mins
                        ;	plo	r5
                        ;	ldn	r5
                        ;	phi	rf
                        ;	inc	r5
                        ;	ldn	r5
                        ;	plo	rf
                        
                        ;	ldi	LOW MM
                        ;	plo	r5
                        ;	ghi	rf
                        ;	str	r5
                        ;	inc	r5
                        ;	glo	rf
                        ;	str	r5
   04ca                 SAVTIME:
                        ;	ldi	HIGH NOUN_VERB	;Get the pointer to Verb Reg
                        ;	phi	r4			;to R(4.1)
   04ca   f8 a8         	ldi	LOW NOUN_VERB+1
   04cc   a4            	plo	r4
   04cd   04            	ldn	r4
   04ce   fa 0f         	ani	$0F
   04d0   fb 02         	xri	$02
   04d2   3a ff         	bnz	SAV02
                        
   04d4   14            	inc	r4
   04d5   04            	ldn	r4
   04d6   fa 0f         	ani	$0F
   04d8   af            	plo	rf
                        
   04d9   8f            	glo	rf
   04da   fb 01         	xri	$01
   04dc   3a e6         	bnz	MOV22
   04de   f8 b1         	ldi	LOW REG1+4	;Hours
   04e0   a4            	plo	r4
   04e1   f8 9b         	ldi	LOW HH
   04e3   a5            	plo	r5
   04e4   30 f9         	br	SAV01
   04e6                 MOV22:
   04e6   8f            	glo	rf
   04e7   fb 01         	xri	$01
   04e9   3a f3         	bnz	MOV23
   04eb   f8 b7         	ldi	LOW REG2+4	;MIN
   04ed   a4            	plo	r4
   04ee   f8 9d         	ldi	LOW MM
   04f0   a5            	plo	r5
   04f1   30 f9         	br	SAV01
   04f3                 MOV23:
   04f3   f8 b7         	ldi	LOW REG2+4	;MIN
   04f5   a4            	plo	r4
   04f6   f8 9d         	ldi	LOW MM
   04f8   a5            	plo	r5
   04f9                 SAV01:
   04f9   04            	ldn	r4
   04fa   55            	str	r5
   04fb   14            	inc	r4
   04fc   15            	inc	r5
   04fd   04            	ldn	r4
   04fe   55            	str	r5
   04ff                 SAV02:
   04ff   dc            	sep	rc
                        
                        ;=========================================================================
                        ;=============================PAGE 0500===================================
                        ;=========================================================================
                        
                        ;*******************************************************
                        ;
                        ;  DSKY DISPLAY PAGE MAP (256 byte SCREEN)
                        ;
                        ;*******************************************************
                        ;This needs to point to its own 256 byte page:
                         
   0500                 	org	$0500
                        
                        ;****************************** MAP *********************************
                        ;
                        ; A1 = 0502 (PROG ACTY)         P1 = 0505  P0 = 0506 (PROG)
                        ; V1 = 054A  V0 =054B (VERB)    N1 = 054D  N0 = 054E (NOUN)
                        
                        ;
                        ; ====================== 0548 (LINE) ================================ 
                        ; 
                        ; SR1 = 0579 R1.4 = 057A r1.3 = 057B r1.2 = 057C r1.1 = 057D r1.0 = 057E  (REG1) 
                        ; SR2 = 05A9 R2.4 = 05AA r2.3 = 05AB r2.2 = 05AB r2.1 = 05AD r2.0 = 05AE  (REG2)
                        ; SR3 = 05D9 R3.4 = 05DA r3.3 = 05DB r3.2 = 05DC r3.1 = 05DD r3.0 = 058E  (REG3)
                        ;*******************************************************************
                        
                        ;initialize by loading the following patterns... not needed if page gets init in program
                        ;Line1:    +0   +1   +2   +3   +4   +5   +6   +7
                        ;Line2:    +8   +9   +a   +b   +c   +d   +e   +f
                        
   0500                 DSKY_L1:
                          
   0500   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $f0, $f0, $00	;0 0500 (PROG ACTY TOP) --- (PROG TOP)
   0504   00 f0 f0 00   
   0508   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $90, $90, $00	;1 0508
   050c   00 90 90 00   
   0510   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $90, $90, $00	;2 0510
   0514   00 90 90 00   
   0518   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $90, $90, $00	;3 0518
   051c   00 90 90 00   
   0520   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $f0, $f0, $00	;4 0520
   0524   00 f0 f0 00   
   0528   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	;  0528 (VERB Line)   (NOUN L LINE)
   052c   00 00 00 00   
                        
   0530                 DSKY_L2: 
   0530   00 00 60 f0   	db	$00, $00, $60, $f0, $00, $f0, $f0, $00	;0 0538 (VV=16  NN=65)
   0534   00 f0 f0 00   
   0538   00 00 20 80   	db	$00, $00, $20, $80, $00, $80, $80, $00	;1 0540
   053c   00 80 80 00   
   0540   00 00 20 f0   	db	$00, $00, $20, $f0, $00, $f0, $f0, $00	;2 0548
   0544   00 f0 f0 00   
   0548   00 00 20 90   	db	$00, $00, $20, $90, $00, $90, $10, $00	;3 0550
   054c   00 90 10 00   
   0550   00 00 70 f0   	db	$00, $00, $70, $f0, $00, $f0, $f0, $00	;4 0558
   0554   00 f0 f0 00   
   0558   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	; 
   055c   00 00 00 00   
   0560                 DSKY_LINE:
   0560   00 ff ff ff   	db	$00, $ff, $ff, $ff, $ff, $ff, $ff, $00	; 0569 (LINE)
   0564   ff ff ff 00   
   0568   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	; 0570 (BLANK)
   056c   00 00 00 00   
   0570                 DSKY_R1:
   0570   00 20 f0 f0   	db	$00, $20, $F0, $f0, $f0, $f0, $f0, $00	;0 0578 (REG1 +/- 3 -- 4 TOP)
   0574   f0 f0 f0 00   
   0578   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;1 0580
   057c   90 90 90 00   
   0580   00 f8 90 90   	db	$00, $F8, $90, $90, $90, $90, $90, $00	;2 0588
   0584   90 90 90 00   
   0588   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;3 0590
   058c   90 90 90 00   
   0590   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;4 0598
   0594   f0 f0 f0 00   
   0598   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	; 05A0 (BLANK)
   059c   00 00 00 00   
   05a0                 DSKY_R2:
   05a0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;0 05A8 (REG2 +/- 3 -- 4 TOP)
   05a4   f0 f0 f0 00   
   05a8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;1 05B0
   05ac   90 90 90 00   
   05b0   00 f8 90 90   	db	$00, $F8, $90, $90, $90, $90, $90, $00	;2 05B8
   05b4   90 90 90 00   
   05b8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;3 05C0
   05bc   90 90 90 00   
   05c0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;4 05C8
   05c4   f0 f0 f0 00   
   05c8   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	;05DO (BLANK)
   05cc   00 00 00 00   
   05d0                 DSKY_R3:
   05d0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;0 05D8 (REG3 +/- 3 -- 4 TOP)
   05d4   f0 f0 f0 00   
   05d8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;1 05EO
   05dc   90 90 90 00   
   05e0   00 f8 90 90   	db	$00, $F8, $90, $90, $90, $90, $90, $00	;2 05E8
   05e4   90 90 90 00   
   05e8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;3 05F0
   05ec   90 90 90 00   
   05f0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;4 05F8
   05f4   f0 f0 f0 00   
   05f8   00 00 00 00    	db	$00, $00, $00, $00, $00, $00, $00, $00	;  0530 (BLANK) (0xFF is the end of Buffer)
   05fc   00 00 00 00   
                        
                        
                        
                        
   0600                 	END
0000  ?             0301  AGC_PROC1     0300  AGC_RET       028a  ASSEM     
009a  CCNT          0099  CDEX          04ab  CFLASHVN      044d  CHKCMD    
0360  CHK_NOUNS     0332  CLR3          0177  CLRCH         0271  CLRTST    
03ba  CLRVN         0098  CMD           044c  CMRET         024f  CONS      
0150  CONTCH        0200  CPRET         0201  CPROC         005e  DIGIT     
0126  DISPCH        00c4  DISPLAY       0500  DSKY_L1       0530  DSKY_L2   
0560  DSKY_LINE     0570  DSKY_R1       05a0  DSKY_R2       05d0  DSKY_R3   
0283  ENTER         016d  FIXCH         0173  FLASH         0488  FLASHVN   
0079  FXDISP        02d4  GETDIG        009b  HH            009b  HHMMSS    
017e  INDC_A        002b  KES           0041  KEY           0095  KEYS      
0020  L0014         0053  L001C         0054  L001D         0022  L0024     
0116  L0066         0122  L0067         012e  L0079         013a  L0080     
01db  L009A         036f  LOAD_MET      00db  MET_OFFSETS    019c  MINUS     
009d  MM            04e6  MOV22         04f3  MOV23         0147  NEXCOL    
0477  NEXNV         0075  NEXTDIG       0375  NEXT_DIG      03aa  NOGO      
02cb  NOHEX         004e  NOKEY         046a  NOUCMD        00c1  NOUN      
022d  NOUNS         00a7  NOUN_VERB     0233  NV001         0470  NVCM1     
00d7  NV_OFFSETS    0198  PLUS          00c3  PROG0         00d4  PROG_OFFSET
00a1  PROG_REG      025c  PROS          00ad  REG1          00b3  REG2      
00b9  REG3          00e1  REG_LINE      0424  RET_WRDEC     041b  S3LOOP    
04f9  SAV01         04ff  SAV02         043f  SAVDIG        04ca  SAVTIME   
0401  SET3          0400  SET3_RET      0416  SETCLR        0414  SETPLS    
0189  SIGN          02ab  SIGNS         009f  SS            0094  STACK     
0021  STARTCLK      01cd  TV_INT        01cb  TV_INT_ret    032a  V16       
0381  V21           0385  V22           0389  V23           038b  V2N       
03a0  V2XCLRL       03c9  V35           032f  V36           00bf  VERB      
0225  VERBS         0462  VERCMD        01c6  VIDEO_LINE    0102  VIP_DS    
0100  VIP_DS_RET    02dd  VNCMD         0425  WRDEC         0482  WRTNV     
019e  WS000         019f  WS001         01ab  WS002         01b9  WSBAR     
8110  bitmap        8100  index         0000  r0            0001  r1        
000a  r10           000b  r11           000c  r12           000d  r13       
000e  r14           000f  r15           0002  r2            0003  r3        
0004  r4            0005  r5            0006  r6            0007  r7        
0008  r8            0009  r9            000a  ra            000b  rb        
000c  rc            000d  rd            000e  re            000f  rf        
0000  start         0000  w             

