                        ;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
                        ;
                        ;	File:		VIPDSKYCLOCKP2.asm
                        ;
                        ;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
                        ; 	Author:	S. Botts
                        ;	Size:		81.2 KB (83,181 bytes)
                        ;	Copyright: (c)2015 by SBOTTS - All righty then.
                        ;
                        ;	Purpose:	Demonstrates an Apollo Guidence Computor (AGC) 
                        ;			(DSKY)Display Keyboard Unit with VIP.  
                        ;	Checksum:	688D
                        ;	CRC-32:	E571B87A
                        ;	Date:		Sat July18,2015, 11:23:35 PM
                        ;	CPU:		RCA 1802 (1802 COSMAC family)
                        ;
                        ;_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/_/
                        
                         
                        ;
                        ;
                        ;****************************(DO NOT MODIFY)**************************************
   0000                 r0		EQU	0	;DMA address 
   0001                 r1		EQU	1	;Interrupt Address 
   0002                 r2		EQU	2	;Stack 
   0003                 r3		EQU	3	;Program Counter 
                        ;****************************Gerneral Use registers****************************
   0004                 r4		EQU	4	;Memory Pointer
   0005                 r5		EQU	5	;Memory Pointer
   0006                 r6		EQU	6	;Memory Pointer- ALSO USED TO STOrE VAr INST
   0007                 r7		EQU	7	;Memory Pointer - HOLDS VAr INSTrUCTION
   0008                 r8		EQU	8	;counter in display routine
   0009                 r9		EQU	9	;counts 61 times per sec - in interrupt (DO NOT MODIFY)
   000a                 ra		EQU	10	;
   000b                 rb		EQU	11	;
   000c                 rc		EQU	12	;CONTROL PC
   000d                 rd		EQU	13	;DISPLAY PC
   000e                 re		EQU	14	;
   000f                 rf		EQU	15	;
                        ; Redundant reg defines...
   000a                 r10		EQU	10	;
   000b                 r11		EQU	11	;
   000c                 r12		EQU	12	;
   000d                 r13		EQU	13	;
   000e                 r14		EQU	14	;
   000f                 r15		EQU	15	;
                        
                        
                        
   0000                 	org	$0000
                        ;
   0000                 start:
   0000   f8 cd         	ldi	LOW TV_INT	;Point to 1861 video interrupt $8D
   0002   a1            	plo	r1
   0003   f8 01         	ldi	HIGH TV_INT	;Point to 1861 video interrupt $8D
   0005   b1            	phi	r1
                        
   0006   f8 94         	ldi	LOW STACK	;R2 is stack in RAM $4D
   0008   a2            	plo	r2 
   0009   f8 00         	ldi	HIGH STACK
   000b   b2            	phi	r2	;Stack
                        
   000c   f8 20         	ldi	LOW L0014		;Make R3 the PC 
   000e   a3            	plo	r3	;Preset all these RN.1 registers to this page.
   000f   f8 00         	ldi	HIGH L0014		;Should be page zero...
   0011   b3            	phi	r3	;PC
                        
                        ;	ghi	r0	;DMA - Should be Page 0
   0012   f8 00         	ldi	$00
                        ;	phi	r1	;Point to Interrupt page
                        ;	phi	r2	;Point to Stack page
                        
                        ;continue clearing the R(N).1 (MSB) counters 
   0014   b4            	phi	r4	;pointer
   0015   b5            	phi	r5	;pointer
   0016   b6            	phi	r6	;Self mod code pointer	
   0017   b7            	phi	r7	;vAR instruction
   0018   b8            	phi	r8	;Clear R8.1 counter in Display
   0019   b9            	phi	r9	;Clear R9.1 61 counts/set
   001a   ba            	phi	ra
   001b   bb            	phi 	rb
                        ;	phi 	rc	;point to key page
   001c   bd            	phi 	rd
   001d   be            	phi 	re
   001e   bf            	phi 	rf
                        ;**********************REG initializations are complete**********************
                        
                        
                        ;Switch PC to R(3)
   001f   d3            	sep	r3		; SET PC to R3 HERE
                        ;Switch INDEX Counter to R(2)
   0020                 L0014:
   0020   e2            	sex	r2		; SET X to R2 HERE
                        
                        ;************************************************************************
                        ; Real Time Clock - Mission Elapsed Time (MET)
                        ;************************************************************************
                        ;
                        ;Description: 
                        ;This is the master background task for VIP_DSKY updated by teh VIDEO 
                        ;Interrupt.
                        ; 
                        ;
                        ;Registers Used:
                        ;	R(9) = Interrupt timer (Do not modify - Read only )
                        ;	R(3) = HHHMMSS Pointer	
                        ;	R(4) = Index Reg R(X)
                        ;	R(5) = NA
                        ;	R(A) = Counter
                        ;
                        ;************************************************************************
                        
                        
   0021                 STARTCLK:
   0021   69            	inp	1		; Ready to start clock -> Turn ON TV!
                        
   0022                 L0024:
   0022   f8 00         	ldi	HIGH KEYS	;
   0024   b4             	phi 	r4		;Use R(4)
   0025   f8 95          	ldi	LOW KEYS	;KEY Buffer
   0027   a4             	plo 	r4
                        
   0028   f8 10          	ldi	$10
   002a   ae             	plo	re
   002b                 KES:	
   002b   2e            	dec	re
                        
   002c   8e            	glo	re
   002d   fa 0f         	ani	$0F	;mask off msb
   002f   54            	str	r4	;store on stack
   0030   e4            	sex	4
   0031   62                	out	2	;output via R(x) -> BUS
                        
   0032   e2               	sex	2
                        
   0033   24             	dec	r4	;point back to buffer
                        
   0034   36 41          	b3	KEY	;key pressed?
                        
   0036   8e             	glo	re
   0037   3a 2b          	bnz	KES	;no - scan keys
                        	
   0039   89            	glo	r9		;get interrupt timer (R9.0) 
   003a   fb 3d         	xri	$3D		;61 counts?
   003c   3a 22         	bnz	L0024		;Nope - check again (key in here?)
   003e   a9            	plo	r9		;YES it is! - Reset interrupt timer and proceed...
                        
                        ;*************************************************************************
                        ; 1 HZ LOOP Begins here... FLASH Q LED to indicate
                        ;*************************************************************************
                        ;First check for key command...
                        ;*************************************************************************
   003f   30 4e          	br	NOKEY
                        
   0041                 KEY:
                        ;======================TEST====================================
                        
                        ; 	ldi	HIGH NOUN_VERB	;point it to some place to store key
                        ; 	phi 	r4			;Use R(4)
                        ; 	ldi	LOW NOUN_VERB+1	;Point to a good screen location
                        ; 	plo 	r4;
                        ;
                        ;
                        ;	glo	re		;use switches for test
                        ;  	ani	$0F		;mask off msb
                        ; 	str	r4
                        ;======================TEST====================================
                        	
   0041   36 41         	b3	$		;Wait here for the key to get released!
                        
   0043   f8 02         	ldi	HIGH	CPROC
   0045   bc            	phi	rc
   0046   f8 01         	ldi	LOW	CPROC
   0048   ac            	plo	rc
   0049   dc            	sep	rc
                        
   004a   f8 00         	ldi	$00		;yes since there was a pressed key 
   004c   b9            	phi	r9		;lets reset the clock timer again
   004d   a9            	plo	r9		;so no overflow occurs
                        
   004e                 NOKEY:
                        
                        ;*****************FLASH Q LED ********************************
                        ; this is a 1 sec on off flash... 
                        ; heart beat used to show RTC is running
                        ; and updates and Display Flashing Digits as needed.
                        ;**************************************************************
                        ;
   004e   39 53         	bnq	L001C		; is Q ON?
   0050   7a            	req			;YES - turn it off
   0051   30 54         	br	L001D
   0053                 L001C:	
   0053   7b            	seq			;NO - Turn it on
                        
                        ;*************************************************************
                        ;***************** TIMER LOOP ********************************
                        ;*************************************************************
                        ;
                        ;This is the Main Clock loop. It does not display the time, but
                        ;it maintains an elapsed timer.  It Does the HH:MM:SS count in 
                        ;RAM and controls the rollovers to xx:59:59 
                        ;Zero Hour is checked on exit and gets reset then if needed.
                        ;
                        
   0054                 L001D:
                        ;	ghi	r3		;Reset Rx.1 to Current page (0)
   0054   f8 00         	ldi	$00		;Reset Rx.1 to page (0)
   0056   b5            	phi	r5		;R5.1 
   0057   b4            	phi	r4		;R4.1 
   0058   b6            	phi	r6		;R6.1 
   0059   b7            	phi	r7		;R7.1 
                        
   005a   f8 9f         	ldi	HHMMSS+5	;Time stored in RAM (HH:MM:SS))
   005c   a4            	plo	r4		;R(4) will be the index
                        ;	plo	r5
   005d   e4             	sex	r4	 	;make R(4) the X Reg
   005e                 DIGIT:
   005e   f0            	ldx			;get time_LSD(x) -> RA.0
   005f   aa            	plo	ra
   0060   1a            	inc 	ra		;Increment the counter in R(A)
   0061   8a            	glo	ra
   0062   54            	str	r4		;put it back in RAM
   0063   8a             	glo	ra
   0064   fb 0a         	xri	$0A		;is it 10? 
   0066   3a 79         	bnz	FXDISP	;Not yet - but we are done here no MSD to increment
                        				;Yes = 0  
   0068   73            	stxd			;then store it time(x) and decrement pointer to point to MSB
                        
   0069   f0            	ldx			;get time_MSD(x) -> RA.0
   006a   aa            	plo	ra
   006b   1a            	inc 	ra		;Increment the counter in R(A)
   006c   8a            	glo	ra
   006d   54            	str	r4		;put it back in RAM
   006e   8a             	glo	ra
   006f   fb 06         	xri	$06		;is it 60? (NOTE:even though we check for 60 hours we'll never get there)
   0071   3a 79         	bnz	FXDISP	;Not yet - but we are done here but hours need checking
                        				;Yes = 0  
   0073   73            	stxd			;then store it time(x) and decrement pointer
   0074   84            	glo	r4		;check was this the last digit? (x=HHMMSS)
   0075                 NEXTDIG:
   0075   fb 99         	xri	HHMMSS-1
   0077   3a 5e         	bnz	DIGIT		;No, get next digit
                        ;	br	FXDISP	;Yes, check if Hours = 24
                        
                        ;
                        ;********************************************
                        ;		FXDISP
                        ;**NOTE** this can move to Main Clock Loop
                        ;********************************************
                        ;Fix the HH display and counters for 24 Hr 
                        ;clock rollover. 23:59:59 -> 00:00:00
                        ;********************************************
                        ;
                        
   0079                 FXDISP:			; fix for current display move mem into RA -> RF
   0079   f8 9a         	ldi	HHMMSS
   007b   a4            	plo	r4
   007c   72            	ldxa			;Pick up 10's hours digit
   007d   f6            	shr			;01 >> 0 + DF
   007e   f6            	shr			;check for hour 20: (Bit 0010)
   007f   3b c3         	bnf	DISPLAY 	;still <20: - not there yet just update the display!
                        
   0081   72            	ldxa			;Pick up 1's Hours
   0082   fb 04         	xri	$04		;is it the hour 24:00?
   0084   3a c3         	bnz	DISPLAY 	; Nope keep going...
                        
                        ;... it's zero hour midnight!
                        
   0086   f8 9a         	ldi 	HHMMSS
   0088   a4            	plo	r4	;then store it time(x) and decrement pointer
   0089   f8 00         	ldi 	$00
   008b   54            	str	r4
   008c   14            	inc	r4
   008d   54            	str	r4	; fall through to display... 
   008e   30 c3         	br	DISPLAY
                        ;======================================================
                        ;
                        ;		PAGE 0 RAM BUFFERS
                        ;
                        ;======================================================
                        
                        ;********************************************
                        ;		IRQ STACK BUFFER
                        ;********************************************
                        ;these next three locations are the stack for 
                        ;the intrerrupt in RAM ...
                        ;********************************************
                        
   0090   00 00 00 00   	db	$00, $00, $00, $00
   0094                 STACK:
   0094   00            	db	$00
   0095                 KEYS:
   0095   00 00 00      	db 	$00, $00, $00
   0098                 CMD:
   0098   00            	db 	$00
   0099                 CDX:
   0099   00            	db 	$00
                        ;********************************************
                        ;		RTC COUNTERS
                        ;********************************************
                        ;Maximum count is 23:59:59 -> 00:00:00
                        ; Note: it is set to 23:59:58 on reset 
                        ;       to test the big rollover
                        ;********************************************
   009a                 HHMMSS:
   009a   02 03         	db	$02, $03	;Hours HH
   009c   05 09         	db 	$05, $09	;Minutes MM
   009e   05 08         	db	$05, $08	;Seconds SS
                        
                        ;******DAY COUNTER 000 -> 365(6) can go here...
                        ;but remember 366 day leap years? 2016, 2020, 2024,2028, 2032...
                        
                        ;*********************************************************************************
                        ;			DSKY DISPLAY FORMAT
                        ;*********************************************************************************
                        ;This is the BUFFER in RAM that the command and prog processes control the values here.  
                        ;It calls VIP_DIS to format and display for the 1861 PIXIE display.
                        ;The upper nibbles control how the output is displayed and special (+/-_) chars are shown
                        ;
                        ; The DISPLAY REGISTERS1-3. ACTY, NOUN, VERB, AND PROG CAN ALL USE THESE FORMAT controls
                        ; All 5 LINES WITH 6 CHARS PER LINE ARE DISPLAYED EACH UPDATE. The formats are:
                        ; $Fn MSB =($F)lash n = digit (flashes this digit alternating the pattern and $00
                        ; $Cn MSB =($C)LEAR n = digit (does not show this digit)
                        ; for (S)ign:
                        ; $0n MSB =($0)CLEAR (OCTAL), n = digit -> CLEARS THE PATTERN NONE OR THIRD "F" KEY
                        ; $1n MSB =($1)"-" (NEGITIVE DEC), n = digit -> STORES THE HORIZONTAL MINUS PATTERN FIRST "F" KEY
                        ; $2n MSB =($2)"+" (POSITIVE DEC), n = digit -> ADDS THE  VERTICAL PLUS PATTERN SECOND "F" KEY
                        ;Just store them here with the conrtol bits set and the display formatter will take 
                        ;care of the display behaviour. 
                        ;*********************************************************************************
                        
                        ;     	-------------------------------
                        ;DIGI=	SD5	D5	D4	D3	D2	D1
                        ;+ADD=	+0	+1	+2	+3	+4	+5
                        ;     	-------------------------------
   00a0                 PROG_REG:
   00a0   c0 a1 c2 c3   	db	$C0,	$A1,	$C2,	$C3,	$00,	$00
   00a4   00 00         
                        
   00a6                 NOUN_VERB:	
                        ;	db	$C0,	$00,	$00,	$C0,	$00,	$00	;Display default with A=00 and B=00
   00a6   c0 fa fa cd   	db	$C0,	$FA,	$FA,	$CD,	$FB,	$FB	;Display default with flashing AA BB
   00aa   fb fb         
                        ;
                        ;====================LINE=======================
                        ;
                        
   00ac                 REG1:
   00ac   52 00 00 00   	db	$52,	$00,	$00,	$00,	$00,	$00	
   00b0   00 00         
   00b2                 REG2:
   00b2   51 00 00 00   	db	$51,	$00,	$00,	$00,	$00,	$00
   00b6   00 00         
   00b8                 REG3:
   00b8   52 00 00 00   	db	$52,	$00,	$00,	$00,	$00,	$00
   00bc   00 00         
                        
                        ;**** Add more VERB/NOUN storage to do more levels...
   00be                 VERB:
   00be   00 00         	db	$00,	$00
   00c0                 NOUN:
   00c0   00 00         	db	$00,	$00
                        
   00c2                 PROG0:
   00c2   00            	db	$00
                        
                        
                        ;
                        ;************************************************************************
                        ;		DISPLAY PROCESS 
                        ;
                        ;************************************************************************
                        ;Description: 
                        ;This is the Simulation tasks for VIP_DSKY runs with these these two 
                        ;subroutines arebcalled to create and format the desired displays.
                        ;
                        ;1) AGC_PROC1= this subrutine simulates some AGC functions to give the
                        ;               display process somthing to display. 
                        ;2) VIP_DS	 = This subroutine simulates the DIS part of the DSKY on a 
                        ;             COSMAC VIP Display.
                        ;Registers Used:
                        ;
                        ;	R(D) = Program Counter (calls the subroutines)
                        ;    R(C) = Program Counter (calls internal subroutines)
                        ;    R(3) = RETURN PC (DO NOT CHANGE in SUBR)
                        ;    R(E) = Key Found (Use with care)
                        ;
                        ;************************************************************************
                        
   00c3                 DISPLAY:
                        
                        ;/////////////////NEW//////////////////////////////
   00c3   f8 03         	ldi 	HIGH AGC_PROC1	;AGC PROCESS DEMO Sub Page
   00c5   bd            	phi	rd
   00c6   f8 01         	ldi 	LOW AGC_PROC1	;AGC PROCESS DEMO Sub entry
   00c8   ad            	plo	rd
   00c9   dd            	sep 	rd			;call AGC DEMO PC = R(D) now
                        
                        
                        
   00ca   f8 02         	ldi 	LOW VIP_DS		;DSKY DISPLAY Sub Page
   00cc   ad            	plo	rd
   00cd   f8 01         	ldi 	HIGH VIP_DS	;DSKY DISPLAY Sub entry
   00cf   bd            	phi	rd
                        	
   00d0   dd            	sep 	rd			;call DiS play! PC = R(D) now
                        
   00d1   30 22         	br	L0024		; returns here -> continue!
                        
                        ;==============================================================
                        ;======================== CONSTANTS =========================== 
                        ;==============================================================
                        ;
                        ;These are used for memory and display pointers
                        ;
                        ;********************************************
                        
   00d3                 PROG_OFFSET:
   00d3   a1            	DB	LOW PROG_REG+1	;ACTY
   00d4   a4            	DB	LOW PROG_REG+4	;P1.D1
   00d5   a5            	DB	LOW PROG_REG+5	;P1.D0
   00d6                 NV_OFFSETS:
   00d6   a6            	DB	LOW NOUN_VERB+0
   00d7   a7            	DB	LOW NOUN_VERB+1
   00d8   aa            	DB	LOW NOUN_VERB+4
   00d9   ab            	DB	LOW NOUN_VERB+5
   00da                 MET_OFFSETS:
                        	
   00da   b0            	DB	LOW REG1+4	;10's HRs R1.D1
   00db   b1            	DB	LOW REG1+5	; 1's HRs R1.D0
   00dc   b6            	DB	LOW REG2+4	;10's MINs R2.D1
   00dd   b7            	DB	LOW REG2+5	; 1's MINs R2.D0
   00de   ba            	DB	LOW REG3+2	;10's SECs R3.D3
   00df   bb            	DB	LOW REG3+3	; 1's SECs R3.D2
                        
   00e0                 REG_LINE:
   00e0   a0            	DB	LOW PROG_REG
   00e1   a6            	DB	LOW NOUN_VERB
   00e2   ac            	DB	LOW REG1
   00e3   b2            	DB	LOW REG2
   00e4   b8            	DB	LOW REG3
                        ;
                        ;=========================================================================
                        ;=============================PAGE 0100===================================
                        ;=========================================================================
   0100                 	org	$0100
                        
                        ;************************************************************************
                        ;DSKY Display Formatter for COSMAC VIP TV
                        ;************************************************************************
   0100                 VIP_DS_RET:
   0100   d3            	sep	r3
   0101   00            	db	$00
   0102                 VIP_DS:
                        ;************************************************************************
                        ;
                        ;Description: This is the DiSplay part of DSKY. Since COSMAC VIP uses
                        ;the 1861 PIXIE display all the registers maintained by the COMMAND Process
                        ;are translated into the video display. It is convenient due to paging to
                        ;use one 256-byte page for this display.  We can fit most of the standard
                        ;DSKY in this space but the horizontal lines between the registers 
                        ;and the NOUN and VERB Lamps are not dispalyed. It is also possible to 
                        ;show the status lamps but this is not implemented in this version, all 
                        ;256 bytes are displayed for each update.  The digits are translated by
                        ;a format code that tells how the display appears:
                        ;
                        ;Use:
                        ;	N = 0 - 9 (Digits)
                        ;	0N = Normal digit
                        ;	CN = Clear the cell (N is not shown on screen)
                        ;	FN = Flash the cell (alternate "N" -> " " based on Q State)
                        ;	5N = Sign  Looks kind of like an "S" 0101b (" ", "+", "-", " ", etc...)
                        ;	50 = x0 (xx00b) = " " (OCTAL)
                        ;	51 = x1 (xx01b) = "-" (DECIMAL NEG)
                        ;	52 = x2 (xx10b) = "+" (DECIMAL POS)
                        ;	53 = x3 (xx11b) = " " (OCTAL)
                        ;	DN = FLASHING SIGN? adds one bit to 5N indicate a flash state (1101b)
                        ;
                        ;The display formatter moves the digits from the OUTPUT_REG and puts them
                        ;in speific locations on the VIDEO_BUF page.  each line is placed as 7 digits
                        ;picked up and stored from R->L pointed to by a column counter by DEC R(x).
                        ;The adddress offsets are added and stored and the R(x) offset is the same
                        ;for REG+R(x) -> VIDEO+R(x) buffer.  The command nybble is masked off and this
                        ;result switch tree determines how the 8 digit bit patterns are stored in the 
                        ;video buffer. Each digit in the OUTPUT_REG translates to 8 video lines in 
                        ;the video buffer.
                        ;
                        ;Registers Used:
                        ;	R(4) = VIDEO_BUFFER Display DESTINATION pointer
                        ;	R(5) = ROM Pattern & Table pointer
                        ;	R(6) = DSKY Registers SOURCE pointer
                        ;	R(7) = Character REG position and DSKY VIDEO COLUMN pointer
                        ;	R(8) = Character display pattern line pointer:
                        ;	R(A) = Temp Storage
                        ;	R(B) = Line Counter?
                        ;	R(C) = Column counter?
                        ;	R(D) = PC for this subroutine
                        ;
                        ;
                        ;VIP MON ROM LOCATIONS USED Defines:
   8100                 index		EQU	8100h		;Offset to patterns in ROM
   8110                 bitmap	EQU	8110h		;Top of bit patterns in ROM "0"
                        ;***********************************************************************************
                        
                        
   0102   f8 81         	ldi	HIGH index		;Set ROM table's page (80xx)to convert patterns
   0104   b5            	phi	r5			;Display Pattern (get 5)  
                        	
   0105   f8 00         	ldi	HIGH REG_LINE	;point to RAM regigster page to get digits
   0107   b7            	phi	r7			;
   0108   ba            	phi	ra
   0109   bc            	phi	rc
   010a   f8 e0         	ldi	LOW REG_LINE	;First digit's offset
   010c   a7            	plo	r7			;DIGIT NIBBLE POINTER (SOURCE)
                        
   010d   f8 01         	ldi	HIGH VIDEO_LINE	;Point to video Page locations
   010f   b6            	phi	r6			;
   0110   f8 c6         	ldi	LOW VIDEO_LINE	;Point to first location
   0112   a6            	plo	r6			;
                        
   0113   f8 04         	ldi	HIGH DSKY_L1	;INDEX point to RAM display page (0300) to store
   0115   b4            	phi	r4			; patterns for char PATTERN lines on the DSKY
                        
                        	
   0116                 L0066:
   0116   f8 06         	ldi	$06		;Max Columns+1
   0118   ab            	plo	rb
   0119   f8 00         	ldi	$00		;clear MSBs too (MAY NOT BE NEEDED)
   011b   bb            	phi	rb
   011c   b8            	phi	r8
                        
   011d   06            	ldn	r6		;get the DSKY OFFSET
   011e   a4            	plo	r4		;storage pointer
                        
   011f   07            	ldn	r7		; Pick up pointer to digit from Source (REG)
   0120   aa            	plo	ra		; Pick up pointed digit from Source (REG)
   0121   ac            	plo	rc		; character index from sSource (REG)
                        
   0122                 L0067:
   0122   0a            	ldn	ra		;load via R(A) but don't increment...
   0123   aa            	plo	ra		;SAVE IT in R(A) for processing
                        
   0124   30 50         	br	CONTCH	;Process Control Nibble
                        
   0126                 DISPCH:
   0126   fc 00         	adi	LOW index	;Point to the pattern in ROM was $A9  (xx00)+ N = Digit
   0128   a5            	plo	r5		;put it in R(5)
   0129   05            	ldn	r5		;Pick up the Nth byte of the Display RAM pattern from ROM table
   012a   a5            	plo	r5
                        		
   012b   f8 05         	ldi	$05		;Do this for all 5 lines of the character bit pattern
   012d   a8            	plo	r8		;Line count in R8.0
                        
   012e                 L0079:
   012e   45            	lda	r5		;get from ROM pattern
   012f   54            	str	r4		;Store on display page
   0130   28            	dec	r8		;next lines
   0131   88            	glo	r8		;Get next digit
   0132   32 3a         	bz	L0080		;All bit patterns stored? YES- get next digit.
   0134   84            	glo	r4		;No keep storing patterns
   0135   fc 08         	adi	$08		;point to next TV line (this points to the byte directly below the last)
   0137   a4            	plo	r4		;on the TV screen
   0138   30 2e         	br	L0079		; get next pattern
   013a                 L0080:
                        
   013a   84            	glo	r4			;get last displayed digit index  
   013b   fb f6         	xri	LOW DSKY_R3+$26	; all digits & lines?
   013d   32 00         	bz	VIP_DS_RET		; yes --> get out of here!
                        
   013f   2b            	dec	rb		; column counter
   0140   8b            	glo	rb
   0141   3a 47         	bnz	NEXCOL	; all 5 digits on this line done? 
   0143   17            	inc	r7		; yes-> index pointers to get next lines
   0144   16            	inc	r6		; (both REG & DSKY Lines)
   0145   30 16         	br	L0066		;back to outside loop to pick up new pointers
                        
                        				; no -> keep going on this line
                        ; do some math on indexes to point to the next DSKY Column
                        ; and...to get another digit
   0147                 NEXCOL:
   0147   84            	glo	r4		; move index R4 to point to next DSKY COLUMN
   0148   fc e1         	adi	$E1		; point to top of next display columnn was e1 (-31)
   014a   a4            	plo	r4
   014b   1c            	inc 	rc		; next digit in REG	(can just index as they are in order)
   014c   8c            	glo	rc		; REG digit index pointer ( may be redundant?)
   014d   aa            	plo	ra
   014e   30 22         	br	L0067		; keep going on the inside loop
                        
                        ;***************************************************
                        ; DISPLAY CONTROL CHAR PROCESSING
                        ;***************************************************
                        ;Assumes entry with byte to be displayed is in R(5)
                        ;with the upper Nibble being the control bits
                        ;and the lower the digit to display
                        ;***************************************************
                        
   0150                 CONTCH:
   0150   8a            	glo	ra	;get the found cont+digit
   0151   fa f0         	ani	$f0	;Mask the random digit
   0153   a5            	plo	r5	;save it in RB.0
                        
   0154   85            	glo	r5
   0155   fb 00         	xri	$00		;=none?
   0157   32 6d         	bz	FIXCH 	;just show it...
                        
   0159   85            	glo	r5
   015a   fb c0         	xri	$C0		;=Clear?
   015c   32 77         	bz	CLRCH		;Clear this char
                        
   015e   85            	glo	r5
   015f   fb f0         	xri	$F0		;=Flash?
   0161   32 73         	bz	FLASH		;alternate this char
                        
   0163   85            	glo	r5
   0164   fb 50         	xri	$50		;=Sign?
   0166   32 89         	bz	SIGN		;"+, -" or clear
                        
   0168   85            	glo	r5
   0169   fb a0         	xri	$A0
   016b   32 7e         	bz	INDC_A	;flashing cursor
                        
                        ;***********NOTE***************************
                        ;also other display indicators "Dx" 
                        ;these may be 4 lines vs. 5 lines
                        ;*****************************************
                        
                        ;ELSE: just fall through here for un implemented or unknown
                        	
   016d                 FIXCH:
   016d   8a            	glo	ra		;get the found cont+digit
   016e   fa 0f         	ani	$0F		;Mask the random control code;
   0170   aa            	plo	ra
   0171   30 26         	br	DISPCH	;just show it..
                        
   0173                 FLASH:
   0173   39 77         	bnq	CLRCH	; if Q is off clear it
   0175   30 6d         	br	FIXCH	; if Q is on just show it..	
                        	
   0177                 CLRCH:
   0177   f8 05         	ldi	$05		;Do this for all 5 lines of the character bit pattern
   0179   a8            	plo	r8		;Line count in R8.0
   017a   f8 00         	ldi	$00		;all lines off
                        ;	plo	 r5
   017c   30 9e         	br	WS000	
                        
                        ;**************************************************************************
                        ;NOTE: this section may be re written to use routine located at WS000
                        ;      enter with R5 = 0 for complete count - should work?
                        ;**************************************************************************
                        ;D0079:
                        ;	glo	r5		;get from ROM pattern
                        ;	str	r4		;Store on display page
                        ;	dec	r8		;next lines
                        ;	glo	r8		;Get next digit
                        ;	bz	L0080		;All bit patterns stored? YES- get next digit.
                        ;	glo	r4		;No keep storing patterns
                        ;	adi	$08		;point to next TV line (this points to the byte directly below the last)
                        ;	plo	r4		;on the TV screen
                        ;	br	D0079		; get next pattern
                        ;**************************************************************************
                        
   017e                 INDC_A:
   017e   f8 05         	ldi	$05		;Writes 5 lines of bit pattern
                        
   0180   a8            	plo	r8		;Line count in R8.0
                        
   0181   f8 ff         	LDI	$FF		;1st pattern 
   0183   39 9e         	bnq	WS000		; is Q ON?
   0185   f8 00         	LDI	$00		;YES then turn the 2nd pattern on
   0187   30 9e         	br	WS000
   0189                 SIGN:
   0189   f8 05         	ldi	$05		;Writes 5 lines of bit pattern
   018b   a8            	plo	r8		;Line count in R8.0
                        
   018c   8a            	glo	ra		;Get the digit
   018d   fb 51          	xri	$51		;is it = "-" ?
   018f   32 9c          	bz	MINUS
                        
   0191   8a            	glo	ra		;Get the digit
   0192   fb 52         	xri	$52		; is it = "+" ?
   0194   32 98         	bz	PLUS		; Yes it is
                        
                        
   0196   30 77         	br	CLRCH		; No anything else - Just clear it
   0198                 PLUS:
   0198   f8 20         	LDI	$20		;write center vert line [|]for "+"
   019a   30 9e         	BR 	WS000
   019c                 MINUS:
   019c   f8 00         	LDI	$00		;CLEAR ALL for "-" or unknown
                        
                        ;****************NOTE: **************************
                        ;Almost the same as DISPCH but puts fixed patterns 
                        ;at location R(4) on the screen vs. from a table...
                        ;also the number of lines must be set 
                        ;****************NOTE: **************************
                        	
   019e                 WS000:			;
   019e   a5            	plo	r5		; fixed pattern is in R5.0
                        				;
   019f                 WS001:
   019f   85            	glo	r5		;max count is set above...
   01a0   54            	str	r4		;put  fixed pattern on screen
   01a1   84            	glo	r4		;point to next TV line 
   01a2   fc 08         	adi	$08		;this points to the byte directly below the last
   01a4   a4            	plo	r4		;on the TV screen
                        
   01a5   28            	dec	r8		;next lines (5 lines high)
   01a6   88            	glo	r8		;All lines filled (or cleared)
   01a7   32 ab         	bz	WS002		;Yes -> done with lines
   01a9   30 9f         	br 	WS001		;No -> next line
                        
   01ab                 WS002:
   01ab   84            	glo	r4		;fix pozition
   01ac   fc f8         	adi	$F8
   01ae   a4            	plo	r4
                        
   01af   8a            	glo	ra		;Get the digit
   01b0   fb 51          	xri	$51		;is it = "-" ?
   01b2   32 b9          	bz	WSBAR		;needs a bar
                        
   01b4   8a            	glo	ra		;Get the digit
   01b5   fb 52         	xri	$52		; is it = "+" ?
   01b7   3a 3a         	bnz 	L0080		;no then just blank -> next digit
                        	
                        
                        ; for a sign always put a cross bar up two lines
                        
   01b9                 WSBAR:
   01b9   84            	glo	r4		;point to last TV line 
   01ba   fc f0         	adi	$F0		;move to the 2 (3?) lines above the last (-24)Was E8
   01bc   a4            	plo	r4		;line on the TV screen
   01bd   f8 f8         	ldi	$F8		;[-] pattern
   01bf   54            	str	r4		;put it on screen
   01c0   84            	glo	r4
   01c1   fc 10         	adi	$10		;Put the index back? was 18
   01c3   a4            	plo	r4		;yup.
   01c4   30 3a         	br 	L0080		;DONE! get next digit
                        
                        
                        ;************************NOT USED IN THIS VERSION***************************************
                        ;This is the table of locations we will pick up and store the digits for display on the 
                        ;TV screen They are defined in DSKY pattern and should not change.  these are the locations
                        ;for V35N16 in AGC running PROG00 - this will display all the regs
                        ;************************NOT USED IN THIS VERSION***************************************
                        
                        ;VIDEO_OFFSET:
                        ;	DB	LOW DSKY_L1+2	; A.1 = 0202 (PROG ACTY) 
                        ;	DB	LOW DSKY_L1+5	; P.1
                        ;	DB	LOW DSKY_L1+6	; P.0
                        
                        ;	DB	LOW DSKY_L2+2	; VERB.1
                        ;	DB	LOW DSKY_L2+3	; VERB.0
                        ;	DB	LOW DSKY_L2+5	; NOUN.1
                        ;	DB	LOW DSKY_L2+6	; NOUN.0
                        
                        ;	DB	LOW DSKY_R1+5	;10HR
                        ;	DB	LOW DSKY_R1+6	;01HR
                        ;	DB	LOW DSKY_R2+5	;10MIN
                        ;	DB	LOW DSKY_R2+6	;01MIN
                        ;	DB	LOW DSKY_R3+3	;10SEC
                        ;	DB	LOW DSKY_R3+4	;01SEC
                        ;************************NOT USED IN THIS VERSION***************************************
                        
   01c6                 VIDEO_LINE:
   01c6   01            	DB	LOW DSKY_L1+1	;+1 to skip first column
   01c7   31            	DB	LOW DSKY_L2+1
   01c8   71            	DB	LOW DSKY_R1+1
   01c9   a1            	DB	LOW DSKY_R2+1
   01ca   d1            	DB	LOW DSKY_R3+1
                        
                        ;*********************************************************************************
                        ; 1861 DISPLAY INTERRUPT
                        ;*********************************************************************************
                        ; Description:
                        ; interrupt routine for 64x32 format (1 page display memory)  
                        ; Output 1: disable graphics, input 1: enable graphics, EF 1: in frame indicator              
                        ;
                        ;Registers Used:
                        ;	R(0) = DMA pointer
                        ;	R(1) = IRQ vector pointer
                        ;	R(2) = STACK pointer
                        ;	R(9) = Counter (1/61 Sec)
                        ;Hardware:
                        ;	EF1 = In-Frame indicator
                        ;
                        ;**********************************************************************************
   01cb                 TV_INT_ret:
   01cb   72            	ldxa		;-> RETURN FROM INTERRUPT (restore pointer)
   01cc   70            	ret
                        ;
   01cd                 TV_INT:		;<-Entry on INT
   01cd   c4            	nop		;Sync
   01ce   22            	dec	r2	;point to free location on stack	
   01cf   78            	sav		;push T
   01d0   22            	dec	r2
   01d1   52            	str	r2	;save D
                        
   01d2   e2            	sex	r2	;Cycles for timing
   01d3   e2            	sex	r2	;Set D=line start address (6 cycles)
                        
   01d4   19            	inc	r9	;increment at 1/61 sec count
                        
   01d5   f8 04         	ldi	HIGH DSKY_L1	; Point to Page # of VIDEO DISP
   01d7   b0            	phi	r0			; display RAM
   01d8   f8 00         	ldi	$00
   01da   a0            	plo	r0
   01db                 L009A:
   01db   80            	glo	r0	;1861 displays a line 1st time (8 cycles)
   01dc   e2            	sex	r2	;SYNC
   01dd   e2            	sex	r2	;reset line start address (6 cycles)
   01de   20            	dec	r0
                        			;1861 displays line 2nd time (8 cycles)
   01df   a0            	plo	r0
   01e0   e2            	sex	r2
   01e1   20            	dec	r0
                        			;1861 displays line 3rd time (8 cycles)
   01e2   a0            	plo	r0
   01e3   e2            	sex	r2	;reset line start address (6 cycles)
   01e4   20            	dec	r0	;
                        
   01e5   a0            	plo	r0
   01e6   3c db         	bn1	L009A			;Keep looping until EF1 = 1 (loops 32 times)
                        
   01e8   30 cb         	br	TV_INT_ret		;Exit on top to restore pointer	
                        	
                        ;=========================================================================
                        ;=============================PAGE 0200===================================
                        ;=========================================================================
                        
                        ;************************************************************************
                        ; VIP_KY
                        ;************************************************************************
                        ;Description: This is the KeY part of DSKY. Since COSMAC VIP only has 16
                        ; keys, some are reused  The secondary command keys (& Key) are contextual
                        ; depending on what state the key command processor is in.
                        ; 
                        ;Use: This computer use a series of commands in the format
                        ; 	Vxx <Enter>  Nxx <enter>
                        
                        ;	several keys outside the normal Hex keys were:
                        ;	A = Verb
                        ;	B = Noun
                        ;	C = Clear (& RST)
                        ;	D = Key Rel (& Proceed)
                        ;	E = Enter (& -)
                        ;	F = +/-
                        ; 
                        ;EXAMPLES:
                        ;  "A", (V1V2 go blank) V1, V2,"C"(Clear: start over), V1, V2... 
                        ;  "E" (Enter: Saves it)
                        ;    -> if a "D" is entered before "E" the original V1V2 will remain...
                        ;    -> if no NOUN is needed "E" will run the VERB command
                        ;    -> if a NOUN is needed N1N2 will flash until a "B" or "D" is entered ...
                        ;   "B", (N1N2 go blank) N1, N2..as before with VERBs "E" (Enter: Saves it)
                        ;    -> if the V+N is not known both will flash 
                        ;    -> If P1 P2 flash indicates another prog needs the display (except idle?)
                        ;   "D" will release the display to that prog.
                        ;
                        ;************************************************************************
                        
   0200                 	org	$0200
                        
                        ;****************************************************************
                        ; COMMAND PROCESSING (PINBALL)
                        ;****************************************************************
                        ;PURPOSE:
                        ;
                        ;Test for the 6 non-numeric (HEX) keys:
                        ;A = VERB
                        ;B = NOUN
                        ;C = REL/Clear
                        ;D = PROCEED
                        ;E = Enter 
                        ;F = +/-
                        ;
                        ;Enter: with found key in RE
                        ;Exit: command 
                        ;REGISTERS USED:
                        ;
                        ;  R(3) = Calling PC (Do not change!)
                        ;  R(4) = Mem Pointer (X)
                        ;  R(5) = Mem Pointer (Storage pointer)
                        ;  R(D) = prog counter
                        ;  R(E) = Character found by key 
                        
                        ;****************************************************************
   0200                 CPRET:
   0200   d3            	sep	r3
   0201                 CPROC:
   0201   8e            	glo	re
   0202   fa 0f         	ani	$0f	;Mask any control bits
   0204   ae            	plo	re	;save the key for test
                        
   0205   8e            	glo	re
   0206   fb 0a         	xri	$0A	;
   0208   32 25         	bz	VERBS	
                        
   020a   8e            	glo	re
   020b   fb 0b         	xri	$0B	;
   020d   32 2d         	bz	NOUNS
                        
   020f   8e            	glo	re
   0210   fb 0c         	xri	$0C	;
   0212   32 4a         	bz	CONS
                        
   0214   8e            	glo	re
   0215   fb 0d         	xri	$0D	;
   0217   32 4c         	bz	PROS
                        	
   0219   8e            	glo	re
   021a   fb 0e         	xri	$0E	;
   021c   32 6b         	bz	ENTER
                        
   021e   8e            	glo	re
   021f   fb 0f         	xri	$0F	;
   0221   32 8c         	bz	SIGNS
                        
   0223   30 aa          	br	NOHEX ;(ret)
                        ;	br	CPRET		
   0225                 VERBS:
   0225   f8 00         	ldi	HIGH NOUN_VERB	;Get the pointer to Verb Reg
   0227   b4            	phi	r4			;to R(4.1)
   0228   f8 a7         	ldi	LOW NOUN_VERB+1
   022a   a4            	plo	r4			;to R(4.0)
   022b   30 33         	br NV001
   022d                 NOUNS:
   022d   f8 00         	ldi	HIGH NOUN_VERB
   022f   b4            	phi	r4
   0230   f8 aa         	ldi	LOW NOUN_VERB+4
   0232   a4            	plo	r4			;to R(4.0)
                        
   0233                 NV001:
   0233   04            	ldn	r4	;get first digit M[R(4)] -> D
   0234   fa 0f         	ani	$0f	;Mask any control bits
   0236   fc c0         	adi	$C0	;Set to flash (or clear) 
   0238   54            	str	r4
   0239   14            	inc	r4	;get next digit 
   023a   04            	ldn	r4
   023b   fa 0f         	ani	$0f	;Mask any control bits
   023d   fc c0         	adi	$C0
   023f   54            	str	r4	
                        
                        
                        ; this section was put in to stop flash on NN
                        ; not needed *ONLY for test*
                        ;	ldi	LOW NOUN_VERB+4 ; Point to Nouns;
                        ;	plo	r4
                        ;	ldn	r4		;get N1.1
                        ;	ani	$0F		;Clear any control bits
                        ;	str	r4
                        ;	inc	r4		;...and N1.0
                        ;	ldn	r4
                        ;	ani	$0F	
                        ;	str	r4
                        
                        ;===========================================================
                        ;CMD byte works like this:
                        ;===========================================================
                        ;(1) the hex DIGIT is the CMD to execure a command process. 
                        ; The command process follows this process so all HEX chars 
                        ; are filtered and only digits will be used.
                        ;(2) As the command processed it takes needed digits
                        ; and puts them in registers, pointed to by the base CMD
                        ; it only puts chars in slots with control nibbles
                        ; 0xFn, 0xCn etc.  The new digit overwrites the control,
                        ;if the slot has no control it skips to next reg.
                        ;(3) CMD then gets cleared so no further processing takes 
                        ;place...i.e. digits with no where to go get ignored!
                        ;===========================================================
                        
   0240   f8 00         	ldi	HIGH CMD	;put in CMD storage 
   0242   b5            	phi	r5		;Index in R(4.1)
   0243   f8 98         	ldi	LOW CMD	;put in CMD storage 
   0245   a5            	plo	r5		;Index in R(4,0)
   0246   8e            	glo	re		;Verb or Noun Command 
   0247   55            	str	r5
   0248   30 00         	br	CPRET	
                        
                        ;NOUNS:
                        ;	ldi	HIGH NOUN_VERB
                        ;	phi	r4
                        ;	ldi	LOW NOUN_VERB+4
                        ;	plo	r4
                        ;	ldn	r4
                        ;	ani	$0f	;Mask any control bits
                        ;	adi	$f0
                        ;	str	r4
                        ;	inc	r4
                        ;	ldn	r4
                        ;	ani	$0f	;Mask any control bits
                        ;	adi	$f0
                        ;	str	r4
                        ;
                        ;
                        ;	ldi	LOW NOUN_VERB+1
                        ;	plo	r4
                        ;	ldn	r4
                        ;	ani	$0F	
                        ;	str	r4
                        ;	inc	r4
                        ;	ldn	r4
                        ;	ani	$0F	
                        ;	str	r4
                        ;
                        ;	ldi	LOW CMD	;Still page 0
                        ;	plo	r4
                        ;	glo	re	;Noun Command 
                        ;	str	r4
                        ;	br	CPRET	
                        
   024a                 CONS:
   024a   30 00         	br	CPRET	
                        
                        ;/////////////////NEW////////////////////////////
                        ;************************************************
                        ;*************PROCEED KEY************************
                        ;************************************************
                        ;This key kills the last command in VERB+1 
                        ;so the display gets returned to the original task.
                        ;in VERB+0.  It should also clear the warning indic
                        ;and any flashing VERB/NOUN +-
                        ;NOTE: V33E does the same thing...
                        ;
                        ;*************************************************
                        
                        
   024c                 PROS:
   024c   f8 bf         	ldi	LOW VERB+1		; CLEAR VERB+1 (last command running)
   024e   a5            	plo	r5
   024f   f8 00         	ldi	HIGH $00		;these are on page 0
   0251   b5             	phi	r5
   0252   55            	str	r5
   0253   f8 c1         	ldi	LOW NOUN+1		;Clear that Noun too.
   0255   a5            	plo	r5
   0256   55            	str	r5
                        
   0257   f8 a7         	ldi	NOUN_VERB+1	;TESTVERB LAMPS
   0259   a4            	plo	r4
   025a   04            	ldn	r4	
   025b   fb f8         	xri	$F8
   025d   32 61         	bz	CLRTST	;are we doing a lamp test?
   025f   30 00         	br	CPRET		;No just exit
                        
   0261                 CLRTST:			;YES- "D" KEY will stop it now
                        ;	ldi	$00
   0261   54            	str	r4		;R(4) should be pointing to VERB
   0262   14            	inc	r4		;CLEARS the ALL BALLS in VERB	
   0263   54            	str	r4
                        
   0264   14            	inc	r4	;CLEARS the ALL BALLS NOUN
   0265   14            	inc	r4	
   0266   54            	str	r4
   0267   14            	inc	r4	
   0268   54            	str	r4
   0269   30 00         	br	CPRET	
                        ;/////////////////NEW////////////////////////////
                        
                        
                        ;************************************************
                        ;*************ENTER KEY***********************
                        ;************************************************
                        ;Assemble VERB and NOUN Bytes and flag to execute!
                        ;non zero in the VERB will be teh FLAG to run
   026b                 ENTER:
                        
                        
   026b   f8 00         	ldi	HIGH $00		;these are on page 0
   026d   b5             	phi	r5
   026e   f8 a7         	ldi	LOW NOUN_VERB+1	; Get current VERB Nybbles
   0270   a5            	plo	r5
   0271   f8 be         	ldi	LOW VERB		; VERB storage 
   0273   a4            	plo	r4
   0274   e5            	sex	r5
                        ;assemble the VERB
   0275   72            	LDXA			;load via R5(X) -> X+1 point to next
   0276   fe            	shl             ;shift it into high nibble
   0277   fe            	shl
   0278   fe            	shl	
   0279   fe            	shl
   027a   f1            	or			;combine nibbles
   027b   54            	str	r4		;store via R(4)
                        
                        ;assemble the NOUN
   027c   f8 aa         	ldi	LOW NOUN_VERB+4	; Get current VERB Nybbles
   027e   a5            	plo	r5
   027f   f8 c0         	ldi	LOW NOUN		; NOUN storage 
   0281   a4            	plo	r4
   0282   72            	LDXA
   0283   fe            	shl             	;shift it into high nibble
   0284   fe            	shl
   0285   fe            	shl	
   0286   fe            	shl
   0287   f1            	or
   0288   54            	str	r4		;store via x
   0289   e2            	sex	r2		;Reset X
                        
   028a   30 00         	br	CPRET	
                        
   028c                 SIGNS:
                        ;*****************************************************************
                        ;**NOTE** FOR TEST ONLY WE CAN ENTER WITH POINTER TO THE SIGN CHAR
   028c   f8 00         	ldi	HIGH REG1 ; Let's use 1st sign for test....
   028e   b4            	phi	r4
   028f   b5            	phi	r5
   0290   f8 99         	ldi	LOW CDX
   0292   a4            	plo	r4
                        ;*****************************************************************
   0293   04            	ldn	r4		; get the digit pointer
                        ;	plo	r5
                        ;	ldn	r4		;pick up the current char
                        	
   0294   fa f0         	ani	$f0		; mask off type
   0296   fb 50         	xri	$50		;are you really a sign?
   0298   3a 00         	bnz	CPRET 	;NO - then i don't care
                        
   029a   04            	ldn	r4		;YES- increment the current sign
   029b   fc 01         	adi	$01		; increment
   029d   fa f3         	ani	$F3		;mask off 1111 0011 for rollover
   029f   54            	str	r4		;put new sign back to (M)[ R(4) ]
                        
   02a0   04            	ldn	r4		;was this the 4th count?
   02a1   fb 53         	xri	$53		;need to Get rid of extra key stroke
   02a3   3a 00         	bnz	CPRET		;no -  we are good
                        
   02a5   f8 50         	ldi	$50		;yes - back to zero!
   02a7   54            	str	r4		;
   02a8   30 00         	br	CPRET	
                        
                        ;So now that we sorted all possible HEX - it must be a digit
                        ;but we need tocheck to see if a command needs a digit...
                        
   02aa                 NOHEX:
   02aa   f8 98         	ldi	LOW CMD	;CMD pointer 
   02ac   a5            	plo	r5		;Index in R(5.0)
   02ad   f8 00         	ldi	HIGH CMD	;CMD pointer 
   02af   b5            	phi	r5		;Index in R(5.1)
                        
   02b0   05            	ldn	r5
   02b1   32 00         	bz	CPRET		; No command to process
   02b3   fb 0a         	xri	$0A
   02b5   32 c1         	bz	VERCMD
                        
   02b7   05            	ldn	r5
   02b8   fb 0b         	xri	$0B
   02ba   32 c9         	bz	NOUCMD
                        
   02bc   f8 00         	ldi	$00
   02be   55            	str	r5		;clear it out if it was 
   02bf   30 00         	br	CPRET		;not a known command...
                        
                        ;OK so we need a VERB Digit...
   02c1                 VERCMD:
   02c1   f8 00         	ldi	HIGH NOUN_VERB	;Get the pointer to Verb Reg
   02c3   b4            	phi	r4			;to R(4.1)
   02c4   f8 a7         	ldi	LOW NOUN_VERB+1
   02c6   a4            	plo	r4			;to R(4.0)
   02c7   30 cf         	br	NVCM1
                        
                        ;OK so we need a NOUN Digit...
   02c9                 NOUCMD:
   02c9   f8 00         	ldi	HIGH NOUN_VERB
   02cb   b4            	phi	r4
   02cc   f8 aa         	ldi	LOW NOUN_VERB+4
   02ce   a4            	plo	r4			;to R(4.0)
                        
   02cf                 NVCM1:
   02cf   04            	ldn	r4	;get the storage location
   02d0   fa f0         	ani	$F0	;check to see if new digit is needed	
   02d2   32 d6         	bz	NEXNV	; no - control is clear so it is loaded
   02d4   30 e1         	br	WRTNV
                        
   02d6                 NEXNV:
   02d6   14            	inc	r4	;increment storage pointer
   02d7   04            	ldn	r4	;get the next storage location
   02d8   fa f0         	ani	$F0	; check for need...	
   02da   3a e1         	bnz	WRTNV	; yes control is there write new one
   02dc   f8 00         	ldi	$00	; no control -  then we are done... 
   02de   55            	str	r5	; kill the command via CMD pointer
   02df   30 00         	br	CPRET	
                        
   02e1                 WRTNV:
   02e1   8e            	glo	re	;finally, get our digit an put it in REG
   02e2   fa 0f         	ani	$0F	; make double sure no control in MSB
   02e4   54            	str	r4
   02e5   30 00         	br	CPRET
                        ;
                        ;=========================================================================
                        ;=============================PAGE 0300===================================
                        ;=========================================================================	
   0300                 	org	$0300	
                        ;************************************************************************
                        ; CMD_PROC  - This page does stuff
                        ;************************************************************************
                        ;The command processor detrmines what is displayed. Each display state is
                        ;Based on the V+N entered by the KEY commands, switch statement jumps to
                        ;active process.  The RTC runs in the background updated by the video interrupt
                        ;from the PIXIE display runs in background all the time the user can choose to 
                        ;show the time (MET or RTC)  or do a couple other things. Not all the 
                        ;AGC commands work, the ones not implemented will be ignored.
                        ;These are to be implemented (demonstrated):
                        ;
                        ;	COMMAND	DISCRIPTION
                        ;	V21NxxE =	Enter DECIMAL in R1
                        ;	V22NxxE =	Enter DECIMAL in R2
                        ;	V23NxxE =	Enter DECIMAL in R3
                        ;	V25N36E = 	Set Clock (SET TIME = RTC)
                        ;	V35E = 	Lamp test (LAMPS)
                        ;	V36E = 	Clear Displays (CLEAR)
                        ;	V37E00E = 	Program 0 (P00h) Note: N00E can be 00 - 99
                        ; 	V16N65E = 	Real Time Clock (MET) 
                        ;	V25N36E = 	Set Clock (SET TIME = RTC)
                        ;
                        ;There is also a fictious command:
                        ;	V20N15E = 	YEAR (YY = 15 will update to next year after 365(6) 
                        ;	This causes the days counter on REG1  to update as well as 
                        ;	the MET clock.  It also incremente PROG 0 -> 7 (Day of week) and
                        ;	the day counter resets at 365 and 366 on the next several LYs
                        ;	Note: if you use this as a clock for several years you will burn
                        ;	the display!
                        ;************************************************************************	
                        ;
                        
   0300                 AGC_RET:
   0300   d3            	sep	r3		;all done with AGC result display to process
   0301                 AGC_PROC1:
   0301   f8 00         	ldi	$00		;all registers are on PAGE 0
   0303   b4            	phi	r4
   0304   b5            	phi	r5
                        
   0305   f8 be         	ldi	LOW	VERB	; Get the current verb
   0307   a4            	plo	r4
   0308   04            	ldn	r4
   0309   32 00         	bz	AGC_RET	;nothing get out of processing
                        
   030b   fb 16         	xri	$16		;VERB 16 =  Decimal Display R1,R2, R3 
   030d   32 25         	bz	V16
                        	
   030f   04            	ldn	r4
   0310   fb 21         	xri	$21		; VERB 21 = Decimal LOAD R1
   0312   32 49         	bz	V21
                        
   0314   04            	ldn	r4
   0315   fb 22         	xri	$22		; VERB 22 = Decimal LOAD R2 
   0317   32 4d         	bz	V22
                        
   0319   04            	ldn	r4
   031a   fb 23         	xri	$23		; VERB 23 = Decimal LOAD R3 
   031c   32 51         	bz	V23
                        
   031e   04            	ldn	r4
   031f   fb 35         	xri	$35		; VERB 35 = LAMP TEST
   0321   32 86         	bz	V35
                        		
   0323   30 6e         	br	GODNOPR	; not a known process
                        
                        ;**************VERB 16**********************
                        ;Moves the counters to display for V=16 N=65E
                        ;from Mission Elapse Time (MET) counters on 
                        ;Page 0000 to show Real Time Clock on the DSKY
                        ;
                        ;********************************************
   0325                 V16:
                        ;	ldi	LOW REG1	;Restore the (+)
                        ;	plo	r4
                        ;	ldi	$52
                        ;	str	r4
                        ;	ldi	LOW REG2
                        ;	plo	r4
                        ;	ldi	$52
                        ;	str	r4
                        ;	ldi	LOW REG3
                        ;	plo	r4
                        ;;	ldi	$52
                        ;	str	r4
                        
                        ;Zero the registers...
   0325   f8 ae         	ldi	LOW	SET3
   0327   ac            	plo	rc
   0328   f8 03         	ldi	HIGH	SET3
   032a   bc            	phi	rc
                        
   032b   f8 00         	ldi	$00	;<<<this can be changed to use a variable
   032d   af            	plo	rf
                        
   032e   f8 b8         	ldi	LOW	REG3	;Set REG3
   0330   dc            	sep	rc
                        
   0331   f8 b2         	ldi	LOW	REG2	;Set REG2
   0333   dc            	sep	rc
                        
   0334   f8 ac         	ldi	LOW	REG1	;Set REG1
   0336   dc            	sep	rc
                        
   0337   f8 9a          	ldi	LOW HHMMSS			;source is clock
   0339   a4             	plo	r4
   033a   f8 da         	ldi	LOW MET_OFFSETS	;destination is REG1 - REG3
   033c   a5            	plo	r5
                        
                        
   033d                 NEXT_DIG:
                        
   033d   05            	ldn	r5		;get the display pointer
   033e   a6            	plo	r6		;R6.0
   033f   72            	ldxa			;Pick up HHMMSS digit, increment index  X+1
   0340   56            	str	r6		;store them in register locations
                        ;	
   0341   15            	inc	r5			; point to next
   0342   84            	glo	r4			;test for done with moves
   0343   fb a0         	xri	LOW HHMMSS+6 
   0345   3a 3d         	bnz	NEXT_DIG		;nope - get next one
                        
   0347   30 00         	br	AGC_RET
                        
                        ;**************VERB 21**********************
                        ;Clear R1 ($0xC0->R1D1 to R1D5)
                        ;Set Sign 
                        ;Load DECIMAL into R1D1 -> R1D5
                        ;
                        ;********************************************
   0349                 V21:
   0349   f8 ac         	ldi	LOW	REG1
   034b   30 53         	br	V2N
                        
                        ;**************VERB 22**********************
                        ;Load DECIMAL into R2D1 -> R2D5
                        ;SAME AS ABOVE
                        ;*******************************************
   034d                 V22:
   034d   f8 b2         	ldi	LOW	REG2
   034f   30 53         	br	V2N
                        
                        ;**************VERB 22**********************
                        ;Load DECIMAL into R3D1 -> R3D5
                        ;SAME AS ABOVE
                        ;*******************************************
   0351                 V23:
   0351   f8 b8         	ldi	LOW	REG3
                        
   0353                 V2N:
   0353   a4            	plo	r4
   0354   f8 00         	ldi	$00
   0356   b4            	phi	r4
   0357   b5            	phi	r5
                        
   0358   f8 99         	ldi	LOW	CDX	;put the index in memory for later
   035a   a5            	plo	r5
   035b   84            	glo	r4
   035c   55            	str	r5
                        
   035d   f8 50         	ldi	$50	;clear the sign
   035f   54            	str	r4
   0360   14            	inc	r4
                        
   0361   f8 05         	ldi	$05	;char count
   0363   a5            	plo	r5
                        	
                        
   0364                 V2XCLRL:			;clear the register 
   0364   f8 c0         	ldi	$C0
   0366   54            	str	r4
   0367   14            	inc	r4
   0368   25            	dec	r5
   0369   85            	glo	r5
   036a   3a 64         	bnz	V2XCLRL
                        
   036c   30 7e         	br	CLRVN		;Done with this verb
                        	
                        
   036e                 GODNOPR:
                        ;assuming PAGE 0000
                        ;/////////////TEST//////////////////////////////////////////////////
                        ;	br	AGC_RET	;FLASH works but we cant seem to get new VERB...
                        ;/////////////TEST//////////////////////////////////////////////////
   036e   f8 a7         	ldi	LOW NOUN_VERB+1
   0370   a4            	plo	r4			;to R(4.0)
                        
   0371   04            	ldn	r4	;get first digit M[R(4)] -> D
   0372   fa 0f         	ani	$0f	;Mask any control bits
   0374   fc f0         	adi	$F0	;Set to flash 
   0376   54            	str	r4
   0377   14            	inc	r4	;get next digit 
   0378   04            	ldn	r4
   0379   fa 0f         	ani	$0f	;Mask any control bits
   037b   fc f0         	adi	$F0
   037d   54            	str	r4
                        
   037e                 CLRVN:	
   037e   f8 be         	ldi	VERB	;Done- clear out old verb
                        
   0380   a4            	plo	r4
   0381   f8 00         	ldi	$00
   0383   54            	str	r4
   0384   30 00         	br	AGC_RET
                        
                        ;/////////////////////NEW//////////////////////////////////
   0386                 V35:
   0386   f8 ae         	ldi	LOW	SET3
   0388   ac            	plo	rc
   0389   f8 03         	ldi	HIGH	SET3
   038b   bc            	phi	rc
                        
   038c   f8 08         	ldi	$08	;<<<this can be changed to use a variable
   038e   af            	plo	rf
                        
   038f   f8 b8         	ldi	LOW	REG3	;Set REG3
   0391   dc            	sep	rc
                        
   0392   f8 b2         	ldi	LOW	REG2	;Set REG2
   0394   dc            	sep	rc
                        
                        
   0395   f8 ac         	ldi	LOW	REG1	;Set REG1
   0397   dc            	sep	rc
                        
   0398   f8 be         	ldi	VERB	;TESTVERB LAMPS
   039a   a4            	plo	r4
   039b   f8 88         	ldi	$88
   039d   54            	str	r4
                        
   039e   f8 a7         	ldi	NOUN_VERB+1
   03a0   a4            	plo	r4
   03a1   f8 f8         	ldi	$F8	;flashing 88 in VERB
   03a3   54            	str	r4
   03a4   14            	inc	r4
   03a5   54            	str	r4
                        
   03a6   14            	inc	r4	;Point to NOUN
   03a7   14            	inc	r4	
   03a8   54            	str	r4
   03a9   14            	inc	r4	
   03aa   54            	str	r4
                        
   03ab   30 00         	br	AGC_RET
                        
                        
                        ;*********************************************************************
                        ;                           SUBROUTINE: SET3
                        ;*********************************************************************
                        ;USE: Load  Registers SUBR
                        ;
                        ;D = REG Addr (on PAGE 0)
                        ;R(C) = PC
                        ;R(D) = CALLING PC (Don't Use)
                        ;*********************************************************************
   03ad                 SET3_RET:
   03ad   dd            	sep	rd	;Restore CALLING PC
   03ae                 SET3:
   03ae   a4            	plo	r4	;Register address in POINTER
   03af   f8 00         	ldi	$00	;Assuming PAGE 0
   03b1   b4            	phi	r4
   03b2   b5            	phi	r5
   03b3   f8 99         	ldi	LOW	CDX	; Character Pointer on PAGE 0
   03b5   a5            	plo	r5
   03b6   84            	glo	r4
   03b7   55            	str	r5
                        ;DO the SIGN for this REG..
   03b8   f8 52         	ldi	$52	;set (+) Sign
   03ba   54            	str	r4
   03bb   14            	inc	r4
                        ;SET the rest of the five digits in the REG
   03bc   f8 05         	ldi	$05	;char counter
   03be   a5            	plo	r5
                        	
                        
   03bf                 S3LOOP:			;clear the register 
                        ;	ldi	$08	;<<<this can be changed to use a variable
   03bf   8f            	glo	rf
   03c0   54            	str	r4
   03c1   14            	inc	r4
   03c2   25            	dec	r5
   03c3   85            	glo	r5
   03c4   3a bf         	bnz	S3LOOP	;all 5 set?
   03c6   30 ad         	br	SET3_RET	;yes! Done RETURN
                        
                        ;*********************************************************************
                        ;                           SUBROUTINE: DELAY1
                        ;*********************************************************************
                        ;USE: Load  Registers SUBR
                        ;
                        ;D = REG Addr (on PAGE 0)
                        ;R(C) = PC
                        ;R(D) = CALLING PC (Don't Use)
                        ;*********************************************************************
   03c8                 DEL1_RET:
   03c8   dd            	sep	rd	;Restore CALLING PC
   03c9                 DELAY1:
   03c9   30 c8         	br	DEL1_RET
   03cb   f8 02         	ldi	$02
   03cd   a5            	plo	r5
                        
   03ce                 DLY01:
   03ce   25            	dec	r5
   03cf   85            	glo	r5
   03d0   3a ce         	bnz	DLY01
                        
   03d2   30 c8         	br	DEL1_RET	
                        ;=========================================================================
                        ;=============================PAGE 0400===================================
                        ;=========================================================================
                        
                        ;*******************************************************
                        ;
                        ;  DSKY DISPLAY PAGE MAP (256 byte SCREEN)
                        ;
                        ;*******************************************************
                        ;This needs to point to its own 256 byte page:
                         
   0400                 	org	$0400
                        
                        ;****************************** MAP *********************************
                        ;
                        ; A1 = 0402 (PROG ACTY)         P1 = 0405  P0 = 0406 (PROG)
                        ; V1 = 044A  V0 =044B (VERB)    N1 = 044D  N0 = 044E (NOUN)
                        
                        ;
                        ; ====================== 0448 (LINE) ================================ 
                        ; 
                        ; SR1 = 0479 R1.4 = 047A r1.3 = 047B r1.2 = 047C r1.1 = 047D r1.0 = 047E  (REG1) 
                        ; SR2 = 04A9 R2.4 = 04AA r2.3 = 04AB r2.2 = 04AB r2.1 = 04AD r2.0 = 04AE  (REG2)
                        ; SR3 = 04D9 R3.4 = 04DA r3.3 = 04DB r3.2 = 04DC r3.1 = 04DD r3.0 = 048E  (REG3)
                        ;*******************************************************************
                        
                        ;initialize by loading the following patterns... not needed if page gets init in program
                        ;Line1:    +0   +1   +2   +3   +4   +5   +6   +7
                        ;Line2:    +8   +9   +a   +b   +c   +d   +e   +f
                        
   0400                 DSKY_L1:
                          
   0400   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $f0, $f0, $00	;0 0400 (PROG ACTY TOP) --- (PROG TOP)
   0404   00 f0 f0 00   
   0408   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $90, $90, $00	;1 0408
   040c   00 90 90 00   
   0410   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $90, $90, $00	;2 0410
   0414   00 90 90 00   
   0418   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $90, $90, $00	;3 0418
   041c   00 90 90 00   
   0420   00 00 ff 00   	db	$00, $00, $ff, $00, $00, $f0, $f0, $00	;4 0420
   0424   00 f0 f0 00   
   0428   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	;  0428 (VERB Line)   (NOUN L LINE)
   042c   00 00 00 00   
                        
   0430                 DSKY_L2: 
   0430   00 00 60 f0   	db	$00, $00, $60, $f0, $00, $f0, $f0, $00	;0 0438 (VV=16  NN=65)
   0434   00 f0 f0 00   
   0438   00 00 20 80   	db	$00, $00, $20, $80, $00, $80, $80, $00	;1 0440
   043c   00 80 80 00   
   0440   00 00 20 f0   	db	$00, $00, $20, $f0, $00, $f0, $f0, $00	;2 0448
   0444   00 f0 f0 00   
   0448   00 00 20 90   	db	$00, $00, $20, $90, $00, $90, $10, $00	;3 0450
   044c   00 90 10 00   
   0450   00 00 70 f0   	db	$00, $00, $70, $f0, $00, $f0, $f0, $00	;4 0458
   0454   00 f0 f0 00   
   0458   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	; 
   045c   00 00 00 00   
   0460                 DSKY_LINE:
   0460   00 ff ff ff   	db	$00, $ff, $ff, $ff, $ff, $ff, $ff, $00	; 0469 (LINE)
   0464   ff ff ff 00   
   0468   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	; 0470 (BLANK)
   046c   00 00 00 00   
   0470                 DSKY_R1:
   0470   00 20 f0 f0   	db	$00, $20, $F0, $f0, $f0, $f0, $f0, $00	;0 0478 (REG1 +/- 3 -- 4 TOP)
   0474   f0 f0 f0 00   
   0478   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;1 0480
   047c   90 90 90 00   
   0480   00 f8 90 90   	db	$00, $F8, $90, $90, $90, $90, $90, $00	;2 0488
   0484   90 90 90 00   
   0488   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;3 0490
   048c   90 90 90 00   
   0490   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;4 0498
   0494   f0 f0 f0 00   
   0498   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	; 04A0 (BLANK)
   049c   00 00 00 00   
   04a0                 DSKY_R2:
   04a0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;0 04A8 (REG2 +/- 3 -- 4 TOP)
   04a4   f0 f0 f0 00   
   04a8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;1 04B0
   04ac   90 90 90 00   
   04b0   00 f8 90 90   	db	$00, $F8, $90, $90, $90, $90, $90, $00	;2 04B8
   04b4   90 90 90 00   
   04b8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;3 04C0
   04bc   90 90 90 00   
   04c0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;4 04C8
   04c4   f0 f0 f0 00   
   04c8   00 00 00 00   	db	$00, $00, $00, $00, $00, $00, $00, $00	;04DO (BLANK)
   04cc   00 00 00 00   
   04d0                 DSKY_R3:
   04d0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;0 04D8 (REG3 +/- 3 -- 4 TOP)
   04d4   f0 f0 f0 00   
   04d8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;1 04EO
   04dc   90 90 90 00   
   04e0   00 f8 90 90   	db	$00, $F8, $90, $90, $90, $90, $90, $00	;2 04E8
   04e4   90 90 90 00   
   04e8   00 20 90 90   	db	$00, $20, $90, $90, $90, $90, $90, $00	;3 04F0
   04ec   90 90 90 00   
   04f0   00 20 f0 f0   	db	$00, $20, $f0, $f0, $f0, $f0, $f0, $00	;4 04F8
   04f4   f0 f0 f0 00   
   04f8   00 00 00 00    	db	$00, $00, $00, $00, $00, $00, $00, $00	;  0430 (BLANK) (0xFF is the end of Buffer)
   04fc   00 00 00 00   
                        
                        
                        
                        
   0500                 	END
0301  AGC_PROC1     0300  AGC_RET       0099  CDX           0177  CLRCH     
0261  CLRTST        037e  CLRVN         0098  CMD           024a  CONS      
0150  CONTCH        0200  CPRET         0201  CPROC         03c8  DEL1_RET  
03c9  DELAY1        005e  DIGIT         0126  DISPCH        00c3  DISPLAY   
03ce  DLY01         0400  DSKY_L1       0430  DSKY_L2       0460  DSKY_LINE 
0470  DSKY_R1       04a0  DSKY_R2       04d0  DSKY_R3       026b  ENTER     
016d  FIXCH         0173  FLASH         0079  FXDISP        036e  GODNOPR   
009a  HHMMSS        017e  INDC_A        002b  KES           0041  KEY       
0095  KEYS          0020  L0014         0053  L001C         0054  L001D     
0022  L0024         0116  L0066         0122  L0067         012e  L0079     
013a  L0080         01db  L009A         00da  MET_OFFSETS    019c  MINUS     
0147  NEXCOL        02d6  NEXNV         0075  NEXTDIG       033d  NEXT_DIG  
02aa  NOHEX         004e  NOKEY         02c9  NOUCMD        00c0  NOUN      
022d  NOUNS         00a6  NOUN_VERB     0233  NV001         02cf  NVCM1     
00d6  NV_OFFSETS    0198  PLUS          00c2  PROG0         00d3  PROG_OFFSET
00a0  PROG_REG      024c  PROS          00ac  REG1          00b2  REG2      
00b8  REG3          00e0  REG_LINE      03bf  S3LOOP        03ae  SET3      
03ad  SET3_RET      0189  SIGN          028c  SIGNS         0094  STACK     
0021  STARTCLK      01cd  TV_INT        01cb  TV_INT_ret    0325  V16       
0349  V21           034d  V22           0351  V23           0353  V2N       
0364  V2XCLRL       0386  V35           00be  VERB          0225  VERBS     
02c1  VERCMD        01c6  VIDEO_LINE    0102  VIP_DS        0100  VIP_DS_RET
02e1  WRTNV         019e  WS000         019f  WS001         01ab  WS002     
01b9  WSBAR         8110  bitmap        8100  index         0000  r0        
0001  r1            000a  r10           000b  r11           000c  r12       
000d  r13           000e  r14           000f  r15           0002  r2        
0003  r3            0004  r4            0005  r5            0006  r6        
0007  r7            0008  r8            0009  r9            000a  ra        
000b  rb            000c  rc            000d  rd            000e  re        
000f  rf            0000  start         
Enter file contents here
